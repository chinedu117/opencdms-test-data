$STORAGE:2
C     PROGRAM REPLMAP
C
C     THIS PROGRAM ALLOWS USER TO DEFINE LINE SEGMENTS WITH A SPECIFY AREA OF 
C     DETAIL (COASTS,LAKES,RIVERS,BOUNDARIES, AND STATES) TO REPLACE CLICOM
C     DEFAULT MAPS.  THE PROGRAM USES THE NORTON EDITOR OR ANY TEXT EDITOR TO
C     ENTRY THE LATITUDE AND LONGITUDE COORDINATES IN DEGREES, MINUTES AND
C     SECONDS.  THE PROGRAM WILL CONVERT THE LAT/LON VALUES TO REAL NUMBERS
C     AND STORE VALUES IN THE CLICOM DATA BASE MAP FILES.  IT ALSO ALLOWS USER
C     TO DISPLAY OR MODIFY THE LINE SEGMENTS THAT USER ALREADY DEFINED.
C
C     *** DEFINE THE INTERFACE TO THE C ROUTINE "SYSTEM"
C
      INTERFACE TO INTEGER*2 FUNCTION SYSTEM [C]
     +        (STRING[REFERENCE])
      CHARACTER*1 STRING
      END
C
      PROGRAM REPLMAP
C
      INTEGER*2    SYSTEM,SLONLAT(4,256),COUNT(4),INDX(4),INXREC(4)
      INTEGER*2    AREA,INDXSAV(4),INXUNIT(4),MPUNIT(4),PRVAREA,NTIMES
      INTEGER*2    ILATDEG,ILATMIN,ILATSEC,OLDLATDG
      INTEGER*2    ILONDEG,ILONMIN,ILONSEC,OLDLONDG
      INTEGER*2    MILONDEG(128),MILATDEG(128),LATSIGN,LONSIGN
      INTEGER*4    INDEX(4),NREC(4)
      CHARACTER*1  RTNCODE,RTNFLG,RTNERR
      CHARACTER*2  INCHAR,NOUP,NOLO,YESUP,YESLO,RTNFLAG
      CHARACTER*40 MAPQUAD(4),INXQUAD(4),LNSGORG,LNSGSAVE,MSGNUM(3)
      CHARACTER*40 MSGFILE,MSGSAVE,MSGTXT,LNSGFILE
      CHARACTER*20 ERRORMSG
      CHARACTER*40 PTFILE,TMPFILE
      CHARACTER*64 HELPFILE,HELPFLE1,HELPFLE2
      CHARACTER*80 OUTMSG,MSGLINE,MSG,CHKFILE
      REAL*4       XLON(4,128),YLAT(4,128),LONREAL,LATREAL
      REAL*4       XLON2(4,128),YLAT2(4,128)
      REAL*4       XMNLON(4),XMXLON(4),YMNLAT(4),YMXLAT(4)
      REAL*4       XMINLON(4),XMAXLON(4),YMINLAT(4),YMAXLAT(4)
      REAL*4       XLONMIN,XLONMAX,YLATMIN,YLATMAX,MAXLON
      REAL*4       MINLON,MINLAT,MAXLAT,NLONREAL(128),NLATREAL(128)
      LOGICAL      ENDSEG,FRSTCALL(4),FIRSTART,FOUND,FLAGMAP(5)
      LOGICAL      FILEFLAG,FIRST,RTNMSG,NEXTREC,EMPTYFLE,NEGLAT
      LOGICAL      NEGLON,LNSEGOK
C
      COMMON /RPLNSEG/   XLON,YLAT,XLON2,YLAT2
      COMMON /XYLATLON/  XMNLON,XMXLON,YMNLAT,YMXLAT,
     +                   XMINLON,XMAXLON,YMINLAT,YMAXLAT
C
C     *** DISPLAY MESSAGES IF THE PROGRAM RUN OUTSIDE THE CLICOM SYSTEM
C
      CHKFILE='P:\DATA\MESSAGES.FTN'
      INQUIRE(FILE=CHKFILE,EXIST=FILEFLAG)
      IF (.NOT.FILEFLAG) THEN
         CALL CLS
         CALL BEEP
         CALL LOCATE(16,0,IERR)
         CALL POSLIN(IR,IC)
         MSG = '           This program must run within CLICOM by'
     +          //' choosing choice #7'
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = '           (Enter a single DOS command) from the'
     +        //' CLICOM Introductory'  
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = '           menu.  Type: REPLMAP and press [Enter].'
         IR = IR + 1
         CALL SCRNMSGI(MSG,IR,14)
         MSG = ' '  
         IR = IR + 2
         CALL SCRNMSGI(MSG,IR,14)
         STOP ' '
      END IF            
C
C     *** INITIALIZE HELP FILE NAMES AND MESSAGE TEXT
C
      HELPFILE = 'P:\HELP\REPLMAP.HLP'
      HELPFLE1 = 'P:\HELP\DTLREPMP.HLP'
      HELPFLE2 = 'P:\HELP\DSPREPMP.HLP'
      CALL GETMSG(625,MSGLINE)
      CALL PARSE1(MSGLINE,78,3,40,MSGNUM,RTNCODE)
      CALL GETMSG(999,MSGLINE)
C
      CALL GETYN(1,2,YESUP,YESLO)
      CALL GETYN(2,2,NOUP,NOLO)
C
C     *** INPUT FILE: LINE SEGMENTS DATA
C
      LNSGORG  = 'O:\MAP\CLICMAP\LINESEG.DAT'
C
C     *** ASK USER WHAT ACTION TO PERFORM: DEFINE, MODIFY, VIEW REPLACEMENT MAP
C
  20  CONTINUE
      CALL CLS
      CALL LOCATE(1,1,IERR)
      CALL GETMNU('REPLACE-MAP ',HELPFILE,ICHOICE)
      IF (ICHOICE.EQ.0) THEN
         CALL CLRMSG(1)
         CALL LOCATE(23,0,IERR)
         STOP ' '
      ELSE IF (ICHOICE.EQ.2) THEN
C
C     *** DISPLAY LINE SEGMENTS THAT ALREADY DEFINED, ASK USER FOR LATITUDE 
C         AND LONGITUDE BOUNDARIES TO VIEW USER DEFINED MAP AND CLICOM MAP
C
         CALL CLS
         RTNFLAG = '  '
         CALL MAPCOORD(10,WLATMN,WLATMX,WLONMN,WLONMX,RTNFLAG)
         IF (RTNFLAG.EQ.'4F') THEN
            GO TO 20
         END IF
         CALL CLS
         CALL RMVIEWMP(0,WLONMN,WLONMX,WLATMN,WLATMX,1,FLAGMAP)
         GO TO 20
      END IF
      CALL LOCATE (10,18,IERR)
      CALL GETMNU('SELECT-MAPDT',HELPFLE1,ITYPE)
C
C     *** OPEN THE FILES: MAP AND INPUT LINE SEGMENTS DATA THAT DEPENDENTS
C         ON THE TYPE OF MAP (e.g. COASTLINES, RIVERS, ETC.)
C
      IF (ITYPE.EQ.0) THEN
         GO TO 20
      END IF
 30   CONTINUE
C
C     *** OPEN THE 'O:\CLIGRAF\MAP\CLICMAP\REPLMAP.ERR' TO WRITE MESSAGES
C         FOUND DURING THE PROCESS OF DEFINE THE LINE SEGMENT
C
      MSGFILE = 'O:\MAP\CLICMAP\REPLMAP.ERR'
      MSGSAVE = MSGFILE(1:23)//'ER1'
      OPEN(71,FILE=MSGFILE,STATUS='NEW',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
      IF (IOCHK.EQ.6415) THEN
         CALL RMSAVEFL(MSGFILE,MSGSAVE)
      ELSE IF (IOCHK.NE.0) THEN
         CALL OPENMSG('O:\MAP\CLICMAP\REPLMAP.ERR ','  REPLMAP ',
     +                 IOCHK)
      END IF
      CLOSE(71,STATUS='DELETE')
      OPEN(71,FILE=MSGFILE,STATUS='UNKNOWN',FORM='FORMATTED')
C
      CALL RMLNSGFL(ITYPE,LNSGFILE,LNSGSAVE,ERRORMSG)
      IF (ICHOICE.EQ.1) THEN
         OPEN(61,FILE=LNSGFILE,STATUS='NEW',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
         IF (IOCHK.EQ.6415) THEN
            CALL WRTMSG(3,622,12,1,0,' ',0)
 35         CALL LOCATE(22,75,IERR)
            CALL GETCHAR(1,INCHAR)
            IF (INCHAR.EQ.YESUP.OR.INCHAR.EQ.YESLO) THEN
               CALL RMSAVEFL(LNSGFILE,LNSGSAVE)
            ELSE IF (INCHAR.EQ.NOUP.OR.INCHAR.EQ.NOLO) THEN
               CALL RMCLOSEF
               GO TO 20
            ELSE
               CALL WRTMSG(2,247,12,1,0,' ',0)
               GO TO 35
            END IF
         ELSE IF (IOCHK.EQ.0) THEN
            CALL RMSAVEFL(LNSGORG,LNSGFILE)
            CLOSE(61)
            CALL RMMODFLE(LNSGFILE,ERRORMSG)
         END IF
         CLOSE(61)
      END IF
C
      CALL RMRSTORE(ITYPE)
      CALL RMMPFILE(ITYPE,MAPQUAD,INXQUAD)
C
C     *** INITIALIZE ALL VARIABLES AND COUNTERS
C
      DO 55 I = 1,4
         NREC(I)   = 1
         COUNT(I)  = 0
         INDXSAV(I)= 1
         INXREC(I) = 1
         INDX(I)   = 0
         FRSTCALL(I) = .TRUE.
         XMNLON(I)   =  999.0
         XMXLON(I)   = -999.0
         YMNLAT(I)   =  999.0
         YMXLAT(I)   = -999.0
         XMINLON(I)  =  999.0
         XMAXLON(I)  = -999.0
         YMINLAT(I)  =  999.0
         YMAXLAT(I)  = -999.0
         DO 45 J = 1,256
            SLONLAT(I,J) = 0
            SLONLAT(I,J) = 0
            SLONLAT(I,J) = 0
            SLONLAT(I,J) = 0
 45      CONTINUE
 55   CONTINUE
      XLONMIN  =  999.0
      YLATMIN  =  999.0
      XLONMAX  = -999.0
      YLATMAX  = -999.0
      OLDLONDG =  999
      OLDLATDG =  999
      ILATDEG  = 0
      ILATMIN  = 0
      ILATSEC  = 0
      ILONDEG  = 0
      ILONMIN  = 0
      ILONSEC  = 0
      LATSIGN  = 0
      LONSIGN  = 0
      NTIMES   = 0
      RTNFLG   = '0'
      LINENUM  = 34
      LNSEGOK  = .FALSE.
      FIRSTART = .TRUE.
      EMPTYFLE = .TRUE.
      FOUND    = .FALSE.
      NEXTREC  = .FALSE.
      FIRST    = .TRUE.
      RTNMSG   = .FALSE.
      PRVAREA  = 3
      AREA     = 3
C
C     *** ALLOW THE USER THE OPTION TO DEFINE LINE SEGMENTS FOR SPECIFY
C         DETAILS OF THE MAP WANTED BY USING THE NORTON EDITOR OR ANY TEXT
C         EDITOR. THERE IS ADDITIONAL INFORMATION IN THE FILE (LINE 1 - 34 ),
C         SO THE USER WILL BEGIN TO ENTER THE LONGITUDE AND LATITUDE VALUES
C         AT LINE 35.  IF YOU WANT TO USE TEXT EDITOR OTHER THAN NORTON EDITOR,
C         YOU NEED TO MODIFY THE BATCH FILE P:\BATCH\ED.BAT.
C
      CALL CLS
      I = SYSTEM('ED '//LNSGFILE//"'"C)
C
 50   CONTINUE
      OPEN(61,FILE=LNSGFILE,STATUS='OLD',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(LNSGFILE,'  REPLMAP      ',IOCHK)
         GO TO 50
      END IF
C 
C     *** SKIP THE FIRST 34 LINES IN THE LINESEG.SEG FILE WHICH ARE
C         INSTRUCTIONS ON HOW TO DEFINE THE LINE SEGMENTS DATA.
C
      DO 60 I = 1,34
         READ(61,*)
  60  CONTINUE
C
      CALL CLS
      CALL LOCATE(5,10,IERR)
      CALL WRTSTR(' Working .....',14,12,0)
C
  80  CONTINUE
      LINENUM = LINENUM + 1
      CALL RMRVALUE(ILATDEG,ILATMIN,ILATSEC,ILONDEG,ILONMIN,ILONSEC,
     +             NEGLAT,NEGLON,RTNERR)
      IF (RTNERR.EQ.'1') THEN
         GO TO 130
      ELSE IF (RTNERR.EQ.'2') THEN
         GO TO 500
      ELSE IF (RTNERR.EQ.'3') THEN
         GO TO 80
      END IF
      FIRSTART = .FALSE.
C
C     *** CHECK THE VALUES ON INPUT FILE FOR CONSISTENTLY WITH LATITUDE AND
C         LONGITUDE VALUES AND CONVERT THEM TO REAL NUMBER
C
      CALL RMDEG2RL(ILONDEG,ILONMIN,ILONSEC,ILATDEG,ILATMIN,ILATSEC,
     +              LONREAL,LATREAL,ENDSEG,RTNCODE,LINENUM,MSGNUM,
     +              MSGFILE,EMPTYFLE,NEGLAT,NEGLON)
      IF (RTNCODE.EQ.'3') THEN
         CALL RMCLOSEF
         GO TO 20
      ELSE IF (RTNCODE.EQ.'5') THEN
         GO TO 80
      END IF
C
C     *** DERTERMINES WHICH FILE SHOULD BE OPENED BY CHECKING THE LAT/LON VALUE
C
      CALL RMCKAREA(ILATDEG,ILATMIN,ILATSEC,ILONDEG,ILONMIN,ILONSEC,
     +         LATREAL,LONREAL,AREA,ENDSEG,PRVAREA,NLATREAL,NLONREAL,
     +         MILATDEG,MILONDEG,MPUNIT,INXUNIT,NTIMES,FOUND,FIRST,
     +         MSGNUM,MSGFILE,LINENUM,RTNFLG,RTNMSG,LATSIGN,LONSIGN)
      IF (RTNFLG.EQ.'3') THEN
         IF (RTNMSG) THEN
            WRITE(71,*)
            CALL GETMSG(616,OUTMSG)
            WRITE(71,'(A78)')OUTMSG
            CALL GETMSG(617,OUTMSG)
            WRITE(71,'(A78)')OUTMSG
            CALL GETMSG(618,OUTMSG)
            WRITE(71,'(A78)')OUTMSG
          END IF  
          CALL RMCLOSEF
          GO TO 20
      END IF
C            
      IF (FOUND.OR.NTIMES.EQ.128) THEN
         DO 121 I = 1,NTIMES
C
C     *** DETERMINE MINIMIUM AND MAXIMIUM OF LON/LAT VALUES OF ALL LINE
C         SEGMENTS WHICH USES TO DISPLAY THE LINE SEGMENTS DEFINED.
C    
            CALL RMMINMAX(NLONREAL(I),NLATREAL(I),XLONMIN,XLONMAX,
     +           YLATMIN,YLATMAX)
C
C     *** WRITE LINE SEGMENTS TO MAP FILE
C
            CALL RMWRTMAP(MILONDEG(I),MILATDEG(I),NLONREAL(I),
     +           NLATREAL(I),INDX,SLONLAT,INDEX,NREC,COUNT,INXREC,
     +           FRSTCALL,AREA,INDXSAV,INXUNIT,MPUNIT,OLDLONDG,
     +           OLDLATDG,NEXTREC)
 121     CONTINUE
C
C     *** RE-INITIALIZE THE ARRAY TO HOLD THE LAT/LON VALUES DEPENDS ON THE
C         AREA THAT WORKING ON IT
C
         XMNLON(AREA) =  999.0
         XMXLON(AREA) = -999.0
         YMNLAT(AREA) =  999.0
         YMXLAT(AREA) = -999.0
         DO 122 J = 1,128
            XLON(AREA,J) = 0.0
            YLAT(AREA,J) = 0.0
 122     CONTINUE
         NTIMES = 0
         LNSEGOK = .TRUE.
      END IF
      GO TO 80
 130  CONTINUE
C
C     *** MAKE SURE THE LAST LINE IS 99 99 99 99 99 99 TO END OF LINE
C         SEGNMENT.  OTHERWISE, IT WILL BE IGNORED.
C
      IF (EMPTYFLE) THEN
          CALL RMDTLMAP(1,ITYPE,YLATMIN,YLATMAX,XLONMIN,XLONMAX,
     +              EMPTYFLE,RTNFLG,FLAGMAP,MSGFILE)
          WRITE(MSGTXT,'(2X,A30)')LNSGFILE
          CALL WRTMSG(6,619,12,0,0,MSGTXT,40)
          CALL WRTMSG(5,627,12,1,1,' ',0)
          CALL CLRMSG(6)
          CALL RMCLOSEF
          CALL RMRSTORE(ITYPE)
          GO TO 20
      END IF
      IF (ILATDEG.NE.99.OR.ILATMIN.NE.99.OR.ILATSEC.NE.99.OR.
     +   ILONDEG.NE.99.OR.ILONMIN.NE.99.OR.ILONSEC.NE.99) THEN
         IF (FIRSTART) THEN
            WRITE(MSGTXT,'(2X,A30)')LNSGFILE
            CALL WRTMSG(6,619,12,1,1,MSGTXT,40)
            CALL WRTMSG(5,627,12,1,1,' ',0)
            CALL CLRMSG(6)
            CALL RMCLOSEF
            CALL RMRSTORE(ITYPE)
            GO TO 20
         ELSE 
            CALL WRTMSG(6,620,12,0,0,' ',0)
            CALL WRTMSG(5,621,12,0,0,' ',0)
            CALL WRTMSG(3,623,12,1,1,MSGFILE,30)
C
C     *** WRITE ERROR MESSAGES TO FILE
C
            CALL GETMSG(620,OUTMSG)
            WRITE(71,*)
            WRITE(71,'(A78)')OUTMSG
            CALL GETMSG(621,OUTMSG)
            WRITE(71,'(A78)')OUTMSG
            CALL CLRMSG(6)
            CALL CLRMSG(5)
            CALL CLRMSG(3)
         END IF
      END IF
C
C     *** END OF DATA - WRITE LAST RECORD INTO MAP AND INDEX FILES.
C         THE LAST RECORD IN THE INDEX FILE MUST BE NREC = - 1 TO
C         SIGNAL THE END OF FILE
C
      DO 145 I = 1,4
         IF (INDXSAV(I).GT.1) THEN
            WRITE(MPUNIT(I),REC=NREC(I)) (SLONLAT(I,K),K=1,256)
            INDEX(I) = INDXSAV(I)
            NREC(I) = - 1
            WRITE(INXUNIT(I),REC=INXREC(I)) NREC(I),INDEX(I),
     +              XMNLON(I),XMXLON(I),YMNLAT(I),YMXLAT(I)
C
C     *** UPDATE THE MAP POINTER FILE
C
            CALL RMWRTPTF(XMINLON,XMAXLON,YMINLAT,YMAXLAT,INXQUAD,
     +              MAPQUAD,ITYPE,I,MSGFILE,PTFILE,TMPFILE,RTNFLG)
            IF (RTNFLG.EQ.'3') THEN
               CALL RMCLOSEF
               GO TO 20
            END IF
         END IF      
 145  CONTINUE
C
C     *** WRITE THE EXPLANATION OF MESSAGE INTO THE FILE
C
      IF (RTNMSG) THEN
         WRITE(71,*)
         CALL GETMSG(616,OUTMSG)
         WRITE(71,'(A78)')OUTMSG
         CALL GETMSG(617,OUTMSG)
         WRITE(71,'(A78)')OUTMSG
         CALL GETMSG(618,OUTMSG)
         WRITE(71,'(A78)')OUTMSG
      END IF  
C
      CALL RMCLOSEF
      CALL CLS
 150  CONTINUE
C
C     *** SAVES THE MIN/MAX OF LAT/LON VALUES FOR ALL DETAIL OF MAP TO THE
C         O:\MAP\CLICMAP\DETAILMP.RMP FILE
C
      CALL RMDTLMAP(1,ITYPE,YLATMIN,YLATMAX,XLONMIN,XLONMAX,
     +              EMPTYFLE,RTNFLG,FLAGMAP,MSGFILE)
C
      CALL LOCATE(1,1,IERR)
      CALL GETMNU('DSP-REPLMAP ',HELPFLE2,IOPT)
      IF (IOPT.EQ.0) THEN
         CALL RMCLOSEF
         GO TO 20
      ELSE IF (IOPT.EQ.1) THEN
         IF (.NOT.LNSEGOK) GO TO 20
         CALL RMWRTMPT(PTFILE,TMPFILE,MSGFILE,RTNFLG)
         IF (RTNFLG.EQ.'3') THEN
            GO TO 20
         END IF
C
C     *** ADD 0.10 TO THE LAT/LON BOUNDARIES, THIS WAY THE MAP WILL DISPLAY AT
c         CENTER OF THE VIEWPORT.        
C
         IF (ABS(XLONMIN).GE.0.10) THEN
            MINLON = XLONMIN - 0.10
         ELSE
            MINLON = XLONMIN - 0.005
         END IF
         MAXLON = XLONMAX + 0.10
C
         IF (ABS(YLATMIN).GE.0.10) THEN
            MINLAT = YLATMIN - 0.10
         ELSE
            MINLAT = YLATMIN - 0.005
         END IF
         MAXLAT = YLATMAX + 0.10
C
C     *** MAKE SURE THE MAXIMUM LONGITUDE OR LATITUDE MUST BE GREATER THAN
C         MINIMUM LONGITUDE OR LATITUDE.
C   
         IF (MINLON.GE.MAXLON) THEN
            MINLON = MINLON - 0.005
         END IF
         IF (MINLAT.GE.MAXLAT) THEN
            MINLAT = MINLAT - 0.005
         END IF
C
C     *** MAKE SURE THE LONGITUDE IS IN THE LIMIT (FROM -180.0 TO 180.0)
C
         IF (MINLON.LT.-180.0) THEN
            MINLON = XLONMIN
         END IF
         IF (MAXLON.GT.180.0) THEN
            MAXLON = XLONMAX 
         END IF
C
C     *** MAKE SURE THE LATITUDE IS IN THE LIMIT (FROM -90.0 TO 90.0)
C
         IF (MINLAT.LT.-90.0) THEN
            MINLAT = YLATMIN
         END IF
         IF (MAXLAT.GT.90.0) THEN
            MAXLAT = YLATMAX
         END IF
C
C     *** DISPLAY THE REPLACEMENT MAP
C
         CALL RMVIEWMP(1,MINLON,MAXLON,MINLAT,MAXLAT,ITYPE,FLAGMAP)
         CALL RMSAVEFL(TMPFILE,PTFILE)
         CLOSE(63,STATUS='DELETE')
         GO TO 150
      ELSE IF (IOPT.EQ.2) THEN
         ICHOICE = 2
         CALL RMCLOSEF
         GO TO 30
      END IF 
C
      STOP ' '
C
C     *** ERROR READING O:\MAP\CLICMAP\LINESEG.SEG FILE ***
C  
 500  CONTINUE
      CALL RMMESSGE(0,LINENUM,' ',LNSGFILE,MSGFILE,RTNFLG)
      CALL RMCLOSEF
      GO TO 20
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMWRTMAP(ILONDEG,ILATDEG,LONREAL,LATREAL,INDX,SLONLAT,
     +           INDEX,NREC,COUNT,INXREC,FRSTCALL,AREA,INDXSAV,
     +           INXUNIT,MPUNIT,OLDLONDG,OLDLATDG,NEXTREC)
C
C     ROUTINE CONVERTS LONGITUDE AND LATITUDE COORDINATES TO WHOLE DEGREE PART
C     AND FRACTIONAL PART OF THE LONGITUDE AND LATITUDE VALUE, AND DETERMINE
C     MAX/MIN FOR EACH LINE SEGMENT BEFORE THE ROUTINE WRITES TO FILE.
C
      INTEGER*2  COUNT(4),SLONLAT(4,256),INDX(4),INXREC(4)
      INTEGER*2  AREA,INDXSAV(4),INXUNIT(4),MPUNIT(4)
      INTEGER*2  OLDLATDG,OLDLONDG
      INTEGER*4  INDEX(4),NREC(4)
      REAL*4     LONREAL,LATREAL
      REAL*4     XLON(4,128),YLAT(4,128),XLON2(4,128),YLAT2(4,128)
      LOGICAL    FRSTCALL(4),NEXTREC
      COMMON /RPLNSEG/ XLON,YLAT,XLON2,YLAT2
C
      COUNT(AREA) = COUNT(AREA) + 1
C
C     *** STORES THE LONGITUDE AND LATITUDE VALUES INTO ARRAY FOR CHECKING
C         MAX/MIN OF ALL LINE SEGMENT WHICH USES TO WRITE INTO THE POINTER
C         (*.FLE) FILE.
C
      XLON(AREA,COUNT(AREA)) = LONREAL
      YLAT(AREA,COUNT(AREA)) = LATREAL
C
C     *** STORES THE LONGITUDE AND LATITUDE VALUES INTO ARRAY FOR CHECKING
C         MAX/MIN OF EACH LINE SEGMENTS WHICH USES TO WRITE INTO THE INDEX
C         (*.INX) FILE.
C
      XLON2(AREA,COUNT(AREA)) = LONREAL
      YLAT2(AREA,COUNT(AREA)) = LATREAL
C
      IF (ILATDEG.EQ.99.AND.ILONDEG.EQ.99) THEN
         INDX(AREA) = INDX(AREA) + 1
         IF (FRSTCALL(AREA)) THEN
            FRSTCALL(AREA) = .FALSE.
            INDEX(AREA) = 1
         ELSE
            INDEX(AREA) = INDXSAV(AREA)
         END IF
         IF (INDX(AREA).NE.256) THEN
            INDXSAV(AREA) = INDX(AREA) + 1
         END IF
         SLONLAT(AREA,INDX(AREA)) = 31000
         COUNT(AREA) = COUNT(AREA) - 1
         IF (INDX(AREA).GE.256) THEN
            INDEX(AREA) = INDXSAV(AREA)
            CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
            CALL RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
         ELSE IF (INDX(AREA).GE.1.AND..NOT.NEXTREC) THEN
            CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
         ELSE IF (NEXTREC) THEN
            INDEX(AREA) = INDXSAV(AREA)
            CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
            NEXTREC = .FALSE.
         END IF
         GO TO 170
      ELSE IF (ILONDEG.NE.OLDLONDG) THEN
         INDX(AREA) = INDX(AREA) + 1
C
C     *** CONVERTS THE LONGITUDE VALUE TO WHOLE DEGREE PART OF LONGITUDE
C         VALUE
C
         IDEGLON = INT(ABS(LONREAL)) + 10000
         SLONLAT(AREA,INDX(AREA)) = IDEGLON
         IF (INDX(AREA).GE.256) THEN
            INDEX(AREA) = INDXSAV(AREA)
            CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
            CALL RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
         END IF
      END IF
C
C     *** CONVERTS THE LONGITUDE VALUE TO FRACTIONAL PART OF LONGITUDE VALUE
C
      IFRCTLON = (ABS(LONREAL)-INT(ABS(LONREAL))) * 10000
      INDX(AREA) = INDX(AREA) + 1
      SLONLAT(AREA,INDX(AREA)) = IFRCTLON
      IF (INDX(AREA).GE.256) THEN
         INDEX(AREA) = INDXSAV(AREA)
         CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
         CALL RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
      END IF
C
      IF (ILATDEG.NE.OLDLATDG) THEN
         INDX(AREA) = INDX(AREA) + 1
C
C     *** CONVERTS THE LATITUDE VALUE TO WHOLE DEGREE PART OF LATITUDE VALUE
C
         IDEGLAT = INT(ABS(LATREAL)) + 10000
         SLONLAT(AREA,INDX(AREA)) = IDEGLAT
         IF (INDX(AREA).GE.256) THEN
            INDEX(AREA) = INDXSAV(AREA)
            CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
            CALL RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
         END IF
      END IF
C
C     *** CONVERTS THE LATITUDE VALUE TO FRACTIONAL PART OF LATITUDE VALUE
C
      IFRCTLAT = (ABS(LATREAL)-INT(ABS(LATREAL))) * 10000
      INDX(AREA) = INDX(AREA) + 1
      SLONLAT(AREA,INDX(AREA)) = IFRCTLAT
      IF (INDX(AREA).GE.256) THEN
          INDEX(AREA) = INDXSAV(AREA)
          CALL RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
          CALL RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
      END IF
C
 170  CONTINUE
      OLDLONDG = ILONDEG
      OLDLATDG = ILATDEG
C
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMWRTLSG(INDX,SLONLAT,NREC,AREA,MPUNIT,NEXTREC)
C
C     THE ROUTINE USES TO STORE ALL DATA LINE SEGMENTS CONSISTS OF: WHOLE
C     DEGREE PART OF THE LONGITUDE, FRACTIONAL PART OF THE LONGITUDE, WHOLE
C     DEGREE PART OF LATITUDE, FRACTIONAL PART OF  THE LATITUDE, AND END OF
C     LINE SEGMENT.
C
      INTEGER*2  SLONLAT(4,256),INDX(4),AREA,MPUNIT(4)
      INTEGER*4  NREC(4)
      LOGICAL    NEXTREC
C
      WRITE(MPUNIT(AREA),REC=NREC(AREA))(SLONLAT(AREA,K),K=1,256)
      NREC(AREA) = NREC(AREA) + 1
      NEXTREC = .TRUE.
      INDX(AREA) = 0
      RETURN 
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMDEG2RL(ILONDEG,ILONMIN,ILONSEC,ILATDEG,ILATMIN,
     +           ILATSEC,LONREAL,LATREAL,ENDSEG,RTNCODE,LINENUM,
     +           MSGTEXT,MSGFILE,EMPTYFLE,NEGLAT,NEGLON)
C
C     ROUTINE CONVERTS THE LON/LAT COORDINATES FROM DEGREES, MINUTES AND
C     SECONDS TO REAL NUMBER AND MAKE SURE THE INPUT VALUES ARE VALID
C
      REAL*4       LATREAL,LONREAL
      INTEGER*2    ILATDEG,ILATMIN,ILATSEC
      INTEGER*2    ILONDEG,ILONMIN,ILONSEC,CODE
      CHARACTER*1  RTNCODE,RTNFLG
      CHARACTER*24 INELNSG,INVALUE
      CHARACTER*40 MSGFILE,MSGTEXT(3),ERRMSG
      CHARACTER*78 OUTMSG
      LOGICAL      ENDSEG,ERRFLG,EMPTYFLE,NEGLON,NEGLAT
C
      ENDSEG = .FALSE.
C
C     *** MAKE SURE ALL INPUT VALUES ARE VALID
C
      IF (ILATDEG.GT.90) THEN
         IF (ILATDEG.EQ.99) THEN
            IF (ILATMIN.NE.99.OR.ILATSEC.NE.99.OR.ILONDEG.NE.99
     +         .OR.ILONMIN.NE.99.OR.ILONSEC.NE.99) THEN
               WRITE(INELNSG,125)ILATDEG,ILATMIN,ILATSEC,' /',
     +         ILONDEG,ILONMIN,ILONSEC
 125           FORMAT(I3,1X,I3,1X,I2,A2,I4,1X,I3,1X,I2)
               CALL GETMSG(626,OUTMSG)
               CALL GETMSG(999,OUTMSG)
               CALL RMMESSGE(1,LINENUM,INELNSG,OUTMSG,MSGFILE,RTNFLG)
               CODE = 1
               ERRFLG = .FALSE.
               GO TO 400
            ELSE IF (ILATMIN.EQ.99.AND.ILATSEC.EQ.99.AND.ILONDEG.EQ.99
     +         .AND.ILONMIN.EQ.99.AND.ILONSEC.EQ.99)THEN
C
C     *** CHECK FOR 99 99 99 99 99 99 TO INDICATE END OF LINE SEGMENT
C
               ENDSEG  = .TRUE.
               GO TO 110
            END IF
         ELSE         
            WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
            CODE = 2
            ERRMSG = MSGTEXT(2)
            ERRFLG = .TRUE.
            GO TO 400
         END IF
      ELSE IF (ILATDEG.LT.-90) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 2
         GO TO 400
      END IF
C
      IF (ILATMIN.GT.59) THEN
         IF (ILATDEG.EQ.9) THEN
            IF (ILATMIN.EQ.99.OR.ILATSEC.EQ.99.OR.ILONDEG.EQ.99.OR.
     +         ILONMIN.EQ.99.OR.ILONSEC.EQ.99) THEN
               WRITE(INELNSG,125)ILATDEG,ILATMIN,ILATSEC,' /',
     +         ILONDEG,ILONMIN,ILONSEC
               CALL GETMSG(626,OUTMSG)
               CALL GETMSG(999,OUTMSG)
               CALL RMMESSGE(1,LINENUM,INELNSG,OUTMSG,MSGFILE,RTNFLG)
               CODE = 1
               ERRFLG = .FALSE.
               GO TO 400
            END IF
         ELSE
            WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
            ERRMSG = MSGTEXT(2)
            ERRFLG = .TRUE.
            CODE = 2
            GO TO 400
         END IF
      ELSE IF (ILATMIN.LT.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 2
         GO TO 400
      END IF
C
      IF (ILATSEC.GT.59) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         CODE = 2
         GO TO 400
      ELSEIF (ILATSEC.LT.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 2
         GO TO 400
      END IF
C
      IF (ILONDEG.GT.180) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      ELSE IF (ILONDEG.LT.-180) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      END IF
C
      IF (ILONMIN.GT.59) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      ELSE IF (ILONMIN.LT.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      END IF
C
      IF (ILONSEC.GT.59) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      ELSE IF (ILONSEC.LT.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      END IF
C
      EMPTYFLE = .FALSE.
C
C     *** CONVERTS DEGREES, MINUTES AND SECONDS TO REAL NUMBER
C
      IF (ILONDEG.LT.0 .OR. NEGLON) THEN
         LONREAL = FLOAT(ILONDEG)-FLOAT(ILONMIN)/60.0
     +             - FLOAT(ILONSEC)/3600.0
      ELSE
         LONREAL = FLOAT(ILONDEG)+FLOAT(ILONMIN)/60.0
     +             + FLOAT(ILONSEC)/3600.0
      END IF
C
C     MAKE SURE THE LONGITUDE VALUE WITHIN THE LIMIT (FROM -180.0 TO 180.0)
C
      IF (LONREAL.GT.180.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      ELSE IF (LONREAL.LT.-180.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILONDEG,ILONMIN,ILONSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 3
         GO TO 400
      END IF
C
      IF (ILATDEG.LT.0 .OR. NEGLAT) THEN
         LATREAL = FLOAT(ILATDEG)-FLOAT(ILATMIN)/60.0
     +             - FLOAT(ILATSEC)/3600.0
      ELSE
         LATREAL = FLOAT(ILATDEG)+FLOAT(ILATMIN)/60.0
     +             + FLOAT(ILATSEC)/3600.0
      END IF
C
C     MAKE SURE THE LATITUDE VALUE WITHIN THE LIMIT (FROM -90.0 TO 90.0)
C
      IF (LATREAL.GT.90.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         CODE = 2
         ERRMSG = MSGTEXT(2)
         ERRFLG = .TRUE.
         GO TO 400
      ELSE IF (LATREAL.LT.-90.0) THEN
         WRITE(INVALUE,'(I5,1X,I4,1X,I4)')ILATDEG,ILATMIN,ILATSEC
         ERRMSG = MSGTEXT(3)
         ERRFLG = .TRUE.
         CODE = 2
         GO TO 400
      END IF
C
 110  CONTINUE
      RTNCODE  = '0'
      RETURN
C
C     *** DISPLAY A MESSAGE, IF THE INPUT VALUE IS INVALID
C
 400  CONTINUE
      IF (ERRFLG) THEN
         CALL RMMESSGE(CODE,LINENUM,INVALUE,ERRMSG,MSGFILE,RTNFLG)
      END IF
      IF (RTNFLG.EQ.'3') THEN
         RTNCODE = '3'
      ELSE
         RTNCODE = '5'
      END IF
C
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMWRTINX(NREC,INDEX,COUNT,INXREC,AREA,INXUNIT)
C
C     THIS ROUTINE USES TO WRITE A DATA POINTER FILE THAT CONSISTS OF
C     REFERENCES: A RECORD, INDEX NUMBER AND MAX OR MIN OF LONGITUDE AND 
C     LATITUDE VALUES FOR EACH LINE SEGMENT WHICH USES TO POINT TO MAP 
C     FILE.  THE LAST RECORD IN THE FILE SHOULD HAVE A RECORD IREC <= 0 WHICH
C     USES TO SIGNAL THE END OF FILE.
C
      INTEGER*2  COUNT(4),INXREC(4),AREA,INXUNIT(4)
      INTEGER*4  NREC(4),INDEX(4)
      REAL*4     XMNLON(4),XMXLON(4),YMNLAT(4),YMXLAT(4)
      REAL*4     XMINLON(4),XMAXLON(4),YMINLAT(4),YMAXLAT(4)
      REAL*4     XLON(4,128),YLAT(4,128)
      REAL*4     XLON2(4,128),YLAT2(4,128)
C
      COMMON /RPLNSEG/   XLON,YLAT,XLON2,YLAT2
      COMMON /XYLATLON/  XMNLON,XMXLON,YMNLAT,YMXLAT,
     +                   XMINLON,XMAXLON,YMINLAT,YMAXLAT
C
C     *** DETERMINES MIN AND MAX OF LON/LAT VALUES FOR EACH LINE SEGMENTS
C         BEFORE WRITES INTO THE INDEX FILE.
C
      DO 100 K= 1,COUNT(AREA)     

         XMINLON(AREA) = AMIN1(XMINLON(AREA),XLON2(AREA,K))
         XMAXLON(AREA) = AMAX1(XMAXLON(AREA),XLON2(AREA,K))
         YMINLAT(AREA) = AMIN1(YMINLAT(AREA),YLAT2(AREA,K))
         YMAXLAT(AREA) = AMAX1(YMAXLAT(AREA),YLAT2(AREA,K))
C
C     *** DETERMINES MIN AND MAX OF LON/LAT VALUES FOR ALL LINE SEGMENTS
C         BEFORE WRITES INTO THE POINTER FILE.
C
         XMNLON(AREA) = AMIN1(XMNLON(AREA),XLON(AREA,K))
         XMXLON(AREA) = AMAX1(XMXLON(AREA),XLON(AREA,K))
         YMNLAT(AREA) = AMIN1(YMNLAT(AREA),YLAT(AREA,K))
         YMXLAT(AREA) = AMAX1(YMXLAT(AREA),YLAT(AREA,K))

 100  CONTINUE
C
      WRITE(INXUNIT(AREA),REC=INXREC(AREA)) NREC(AREA),INDEX(AREA),
     +     XMNLON(AREA),XMXLON(AREA),YMNLAT(AREA),YMXLAT(AREA)
      INXREC(AREA) = INXREC(AREA) + 1
      COUNT(AREA)  = 0
      RETURN
      END

******************************************************************************
$PAGE
      SUBROUTINE RMVIEWMP(VIEWCODE,XLONMN,XLONMX,YLATMN,YLATMX,ITYPE,
     +                    FLAGMAP)
C
C     ROUTINE TO ALLOW THE USER TO DISPLAY THE LINE SEGMENTS DEFINED
C
C     NOTE :    VIEWCODE = 0 ----> DISPLAY REPLACEMENT MAP AND CLICOM MAP
C               VIEWCODE = 1 ----> DISPLAY ONLY REPLACEMENT MAPS
C
      INTEGER*2    IDUM1,IDUM2(16),VIEWCODE
      CHARACTER*1  RTNFLG
      CHARACTER*2  INCHAR
      CHARACTER*20 DSPMSG
      CHARACTER*40 MSGFILE
      LOGICAL      FLAGMAP(5),EMPTYFLE
C
C     *** INITIALIZE
C
      DO 10 I = 1,5
         FLAGMAP(I) = .TRUE.
 10   CONTINUE
      ICOAST  = 0
      IBORDER = 0
      IRIVER  = 0
      ILAKE   = 0
      ISTATE  = 0
C       
C     ***  SET HALO GRAPHICS ENVIRONMENT 
C
      CALL BGNHALO(10,IDUM1,IDUM2)      
      CALL BGNQCMAP(XLONMN,YLATMN,XLONMX,YLATMX,XKWMX,YKWMX)
C
      CALL INQCRA(MAXCLR)
      CALL SETCOL(MAXCLR)
      CALL SETXPA(8,14)
      CALL SETXPA(9,4)
      CALL KWBORD
C
C     *** DRAWS THE MAP OUTLINES REQUESTED
C
      IF (ITYPE.EQ.1) THEN
         ICOAST = 1
         ICODE = 1
         CALL SETCOL(11)
         CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
      ELSE IF (ITYPE.EQ.3) THEN
         IBORDER = 1
         ICODE = 3
         CALL SETCOL(15)
         CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
      ELSE IF (ITYPE.EQ.5) THEN
         ISTATE = 0
         ICODE = 5
         CALL SETCOL(12)
         CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
      ELSE IF (ITYPE.EQ.2) THEN
         IRIVER = 1
         ICODE = 2
         CALL SETCOL(14)
         CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
      ELSE IF (ITYPE.EQ.4) THEN
         ILAKE = 1
         ICODE = 4
         CALL SETCOL(10)
         CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
      END IF
C
C     *** ALLOWS USER TO INCLUDE/EXCLUDE MAP DETAIL LEVELS
C      
      XWIN = .05
      YWIN = .95
 100  CONTINUE
      IF (VIEWCODE.EQ.1) THEN
         CALL RMDTLMAP(0,ITYPE,YLATMIN,YLATMAX,XLONMIN,XLONMAX,
     +              EMPTYFLE,RTNFLG,FLAGMAP,MSGFILE)
      END IF
      CALL GETCHAR(1,INCHAR)
 101  CALL GRAFMNU(1,46,XWIN,YWIN,98,INCHAR)
      IF (INCHAR.EQ.'4F'.OR.INCHAR.EQ.'ES') THEN
         CALL CLOSEG
         RETURN 
      ELSE IF (INCHAR.EQ.'1 ') THEN
         IF (ICOAST.EQ.0) THEN
            ICOAST = 1
            CALL SETCOL(11)
         ELSE
            ICOAST = 0
            CALL SETCOL(0)
         END IF
         ICODE = 1
         IF (FLAGMAP(1)) THEN
            CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
         ELSE
            DSPMSG = ' COASTLINES'
            GO TO 150
         END IF
      ELSE IF (INCHAR.EQ.'2 ') THEN
         IF (IRIVER.EQ.0) THEN
            IRIVER = 1
            CALL SETCOL(14)
         ELSE
            IRIVER = 0
            CALL SETCOL(0)
         END IF
         ICODE = 2
         IF (FLAGMAP(2)) THEN
            CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
         ELSE
            DSPMSG = ' RIVERS'
            GO TO 150
         END IF
      ELSE IF (INCHAR.EQ.'3 ') THEN
         IF (IBORDER.EQ.0) THEN
            IBORDER = 1
            CALL SETCOL(15)
         ELSE
            IBORDER = 0            
            CALL SETCOL(0)
         END IF
         ICODE = 3
         IF (FLAGMAP(3)) THEN
            CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
         ELSE
            DSPMSG = ' BORDERS'
            GO TO 150
         END IF
      ELSE IF (INCHAR.EQ.'4 ') THEN
         IF (ILAKE.EQ.0) THEN
            ILAKE = 1
            CALL SETCOL(10)
         ELSE
            ILAKE = 0
            CALL SETCOL(0)
         END IF
         ICODE = 4
         IF (FLAGMAP(4)) THEN
            CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
         ELSE
            DSPMSG = ' LAKES ISLANDS'
            GO TO 150
         END IF
      ELSE IF (INCHAR.EQ.'5 ') THEN
         IF (ISTATE.EQ.0) THEN
            ISTATE = 1
            CALL SETCOL(12)
         ELSE
            ISTATE = 0
            CALL SETCOL(0)
         END IF
         ICODE = 5
         IF (FLAGMAP(5)) THEN
            CALL KWLAND(XLONMN,YLATMN,XLONMX,YLATMX,ICODE,IFLAG)
         ELSE
            DSPMSG = ' STATES'
            GO TO 150
         END IF
      END IF
      GO TO 100
 150  CONTINUE
      CALL BEEP
      CALL GRAFNOTE(.1,.95,615,202,DSPMSG,15,'  ')
      GO TO 101
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMWRTPTF(XMINLON,XMAXLON,YMINLAT,YMAXLAT,INXNAME,
     +           MAPNAME,MAPTYPE,AREA,MSGFILE,PTFILE,TMPFILE,RTNFLG)
C     
C     ROUTINE USES TO UPDATE THE MAP POINTER FILES.
C
      CHARACTER*1  RTNFLG
      CHARACTER*6  OUTFRM
      CHARACTER*40 INXNAME(4),MAPNAME(4),PTFILE
      CHARACTER*40 COASTFLE,RIVERFLE,LAKESFLE,BORDRFLE,STATEFLE
      CHARACTER*40 COASTSAV,ALLFILES,SAVEFLES,MSGFILE,TMPFILE
      CHARACTER*72 LINE(60),BLANK,TEMP,FILE1,FILE2
      REAL*4       XMINLON(4),XMAXLON(4),YMINLAT(4),YMAXLAT(4)
      REAL*4       XMNS(16),XMXS(16),YMNS(16),YMXS(16)
      REAL*4       XMIN,XMAX,YMIN,YMAX,XXMN,XXMX,YYMN,YYMX
      INTEGER*2    MAPTYPE,AREA
      LOGICAL      LONFLG,LATFLG
      DATA         BLANK /'       '/
C
      DO 20 K= 1,16
         XMNS(K) = 999.0
         XMXS(K) =-999.0
         YMNS(K) = 999.0
         YMXS(K) =-999.0
  20  CONTINUE
      XMIN =  999.0
      XMAX = -999.0
      YMIN =  999.0
      YMAX = -999.0
      IDUMMY = 99
      DO 30 J = 1,60
         LINE(J) = BLANK
 30   CONTINUE
C
C     *** CREATE A DUMMY LINE FOR SKIPPING LINE IF FOUND
C
      WRITE(TEMP,450)IDUMMY,IDUMMY,XMIN,XMAX,YMIN,YMAX
C
      ALLFILES = 'O:\MAP\*.FLE'
      SAVEFLES = 'O:\MAP\*.ORG'
      COASTFLE = 'O:\MAP\COAST.FLE'
      RIVERFLE = 'O:\MAP\RIVERS.FLE'
      BORDRFLE = 'O:\MAP\BOUNDARY.FLE'
      LAKESFLE = 'O:\MAP\LAKES.FLE'
      STATEFLE = 'O:\MAP\STATES.FLE'
C
C     *** SAVES THE ORGINAL (*.FLE) POINTER FILES
C
      COASTSAV = COASTFLE(1:13)//'ORG'
      OPEN(72,FILE=COASTSAV,STATUS='OLD',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL RMSAVEFL(ALLFILES,SAVEFLES)
         CLOSE(72)
      END IF
C
      IF (MAPTYPE.EQ.1) THEN
         PTFILE = COASTFLE
         TMPFILE= COASTFLE(1:13)//'TMP'
      ELSE IF (MAPTYPE.EQ.2) THEN
         PTFILE  = RIVERFLE
         TMPFILE = RIVERFLE(1:14)//'TMP'
      ELSE IF(MAPTYPE.EQ.3) THEN
         PTFILE  = BORDRFLE
         TMPFILE = BORDRFLE(1:16)//'TMP'
      ELSE IF (MAPTYPE.EQ.4) THEN
         PTFILE  = LAKESFLE
         TMPFILE = LAKESFLE(1:13)//'TMP'
      ELSE IF (MAPTYPE.EQ.5) THEN
         PTFILE  = STATEFLE
         TMPFILE = STATEFLE(1:14)//'TMP'
      END IF
C
C     *** OPENS THE MAP POINTER FILE: COAST.FLE, RIVERS.FLE,... ETC
C
 50   CONTINUE
      OPEN(52,FILE=PTFILE,STATUS='OLD',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(PTFILE,' REPLMAP      ',IOCHK)
         GO TO 50
      END IF
C
C     *** READS MAP POINTER FILES: COAST.FLE, RIVERS.FLE,... ETC
C
      INUMBER = 1
      ICOUNT  = 0
      ILINE   = 1
      DO 100 I=1,60
         READ(52,'(A72)',END=120,ERR=999)LINE(I)
  100  CONTINUE
C
 120  CONTINUE
      REWIND(52)
      READ(52,*,END=999,ERR=999)NLINE
C
C     *** DETERMINES WHICH LINE IN THE MAP POINTER FILE SHOULD BE UPDATED
C         DEPENDENT ON THE AREA WORKING ON
C
      DO 200 K=1,NLINE
         LONFLG = .FALSE.
         LATFLG = .FALSE.
         ILINE = ILINE + 3
         INUMBER = INUMBER + 1
         READ(52,'(A72)',END=200,ERR=999) FILE1
         INUMBER = INUMBER + 1
         READ(52,'(A72)',END=200,ERR=999) FILE2
         INUMBER = INUMBER + 1
         READ(52,*,END=200,ERR=999) IXSW,IYSW,XMN,XMX,YMN,YMX
         IF (AREA.EQ.1.AND.IXSW.EQ.-1.AND.IYSW.EQ.1) THEN
            GO TO 160
         ELSE IF (AREA.EQ.2.AND.IXSW.EQ.-1.AND.IYSW.EQ.-1) THEN
            GO TO 160
         ELSE IF (AREA.EQ.3.AND.IXSW.EQ.1.AND.IYSW.EQ.1) THEN
            GO TO 160
         ELSE IF (AREA.EQ.4.AND.IXSW.EQ.1.AND.IYSW.EQ.-1) THEN
            GO TO 160
         ELSE
            GO TO 200
         END IF
 160     CONTINUE
         JXSW = IXSW
         JYSW = IYSW
         XXMN = XMN
         XXMX = XMX
         YYMN = YMN
         YYMX = YMX
C
C     *** SPECIAL CHECK FOR STATES.FLE FILE, SINCE THE STATE BODERS ARE ONLY
C         AVAILABLE FOR AREAS IN THE WESTERN HEMISPHERE.
C
         IF (MAPTYPE.EQ.5) THEN
            IF (XMINLON(AREA).GT.XXMN.AND.XMINLON(AREA).LT.XXMX.OR.
     +         XMAXLON(AREA).GT.XXMN.AND.XMAXLON(AREA).LT.XXMX) THEN
               LONFLG = .TRUE.
            END IF
            IF (YMINLAT(AREA).GT.YYMN.AND.YMINLAT(AREA).LT.YYMX.OR.  
     +         YMAXLAT(AREA).GT.YYMN.AND.YMAXLAT(AREA).LT.YYMX) THEN
               LATFLG = .TRUE.
            END IF
         ELSE
            IF (XMINLON(AREA).GE.XXMN.AND.XMINLON(AREA).LE.XXMX.OR.
     +         XMAXLON(AREA).GE.XXMN.AND.XMAXLON(AREA).LE.XXMX) THEN
               LONFLG = .TRUE.
            END IF
            IF (YMINLAT(AREA).GE.YYMN.AND.YMINLAT(AREA).LE.YYMX.OR.  
     +         YMAXLAT(AREA).GE.YYMN.AND.YMAXLAT(AREA).LE.YYMX) THEN
               LATFLG = .TRUE.
            END IF
         END IF
         IF (LONFLG.AND.LATFLG) THEN
            ICOUNT = ICOUNT + 1
            LINE(ILINE - 2) = 'YES'
            LINE(ILINE - 1) = 'YES'
            LINE(ILINE)     = TEMP            
            XMNS(ICOUNT) = XXMN
            XMXS(ICOUNT) = XXMX
            YMNS(ICOUNT) = YYMN
            YMXS(ICOUNT) = YYMX
         END IF
 200  CONTINUE
C
C     *** DETERMINE THE MIN/MAX OF LINE SEGMENT IN EACH AREA 
C
      DO 250 K = 1,ICOUNT
         XMAX=AMAX1(XMAX,XMXS(K))
         XMIN=AMIN1(XMIN,XMNS(K))
         YMAX=AMAX1(YMAX,YMXS(K))
         YMIN=AMIN1(YMIN,YMNS(K))
 250  CONTINUE
C
      IF (ICOUNT.GT.0) THEN
         KLINE = NLINE - ICOUNT + 1
         WRITE(LINE(1),'(I2)')KLINE
      END IF
      REWIND(52)
      NUMLINE = NLINE * 3 + 1
      DO 370 I = 1, NUMLINE
         IF (LINE(I).NE.'YES') THEN
            IF (LINE(I).NE.TEMP) THEN
               CALL GETFRMT(LINE(I),OUTFRM)
               WRITE(52,OUTFRM) LINE(I)            
            END IF
         END IF
 370  CONTINUE
      IF (XMAX.NE.-999.0.OR.XMIN.NE.999.0) THEN
         WRITE(52,'(A40)') MAPNAME(AREA)
         WRITE(52,'(A40)') INXNAME(AREA)
         WRITE(52,450) JXSW,JYSW,XMIN,XMAX,YMIN,YMAX
      END IF
      CLOSE(52)
      CLOSE(72)
      RETURN
C
 450  FORMAT(I2,',',I2,4(',',F6.1))
C
C     *** ERROR READING THE POINTER FILE \CLIGRAF\MAP\*.FLE
C
 999  CONTINUE
      CALL RMMESSGE(0,INUMBER,' ',PTFILE,MSGFILE,RTNFLG)
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMSAVEFL(FILEOPEN,FILESAVE)
C
C     ROUTINE SAVES A FILE BEFORE THE PROGRAM MAKES ANY MODIFICATIONS TO A
C     FILE, SO THE USER CAN RETRIEVE THE ORIGINAL FILE IF NEEDED. 
C
      CHARACTER*40  FILESAVE,FILEOPEN
      CHARACTER*80  LINETXT
      INTEGER*2     SYSTEM
C
      LINETXT = ' '      
      WRITE(LINETXT,50)FILEOPEN,FILESAVE
 50   FORMAT('COPY ',A30,1X,A30,' >> NUL')
      LGTH = LNG(LINETXT)+1
      LINETXT(LGTH:LGTH) = CHAR(0)    
      I = SYSTEM(LINETXT)
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMMPFILE(ITYPE,MAPQUAD,INXQUAD)
C
C     ROUTINE OPENS MAP, INDEX FILES
C
      CHARACTER*40 MAPQUAD(4),INXQUAD(4)
C
C     *** MAP NAMES FOR LINE SEGMENTS IN DIFFERENCE QUADRANTS
C
      IF (ITYPE.EQ.1) THEN
         MAPQUAD(1) = 'O:\MAP\CLICMAP\RPCLMPC1.CST'
         MAPQUAD(2) = 'O:\MAP\CLICMAP\RPCLMPC2.CST'
         MAPQUAD(3) = 'O:\MAP\CLICMAP\RPCLMPC3.CST'
         MAPQUAD(4) = 'O:\MAP\CLICMAP\RPCLMPC4.CST'
      ELSE IF (ITYPE.EQ.2) THEN
         MAPQUAD(1) = 'O:\MAP\CLICMAP\RPCLMPR1.RIV'
         MAPQUAD(2) = 'O:\MAP\CLICMAP\RPCLMPR2.RIV'
         MAPQUAD(3) = 'O:\MAP\CLICMAP\RPCLMPR3.RIV'
         MAPQUAD(4) = 'O:\MAP\CLICMAP\RPCLMPR4.RIV'
      ELSE IF(ITYPE.EQ.3) THEN
         MAPQUAD(1) = 'O:\MAP\CLICMAP\RPCLMPB1.BDY'
         MAPQUAD(2) = 'O:\MAP\CLICMAP\RPCLMPB2.BDY'
         MAPQUAD(3) = 'O:\MAP\CLICMAP\RPCLMPB3.BDY'
         MAPQUAD(4) = 'O:\MAP\CLICMAP\RPCLMPB4.BDY'
      ELSE IF (ITYPE.EQ.4) THEN
         MAPQUAD(1) = 'O:\MAP\CLICMAP\RPCLMPL1.LAK'
         MAPQUAD(2) = 'O:\MAP\CLICMAP\RPCLMPL2.LAK'
         MAPQUAD(3) = 'O:\MAP\CLICMAP\RPCLMPL3.LAK'
         MAPQUAD(4) = 'O:\MAP\CLICMAP\RPCLMPL4.LAK'
      ELSE IF (ITYPE.EQ.5) THEN
         MAPQUAD(1) = 'O:\MAP\CLICMAP\RPCLMPS1.STS'
         MAPQUAD(2) = 'O:\MAP\CLICMAP\RPCLMPS2.STS'
         MAPQUAD(3) = 'O:\MAP\CLICMAP\RPCLMPS3.STS'
         MAPQUAD(4) = 'O:\MAP\CLICMAP\RPCLMPS4.STS'
      END IF
C
C     *** INDEX FILES NAME FOR DIFFERENCE QUADRANTS
C
      INXQUAD(1) = MAPQUAD(1)(1:24)//'INX'
      INXQUAD(2) = MAPQUAD(2)(1:24)//'INX'
      INXQUAD(3) = MAPQUAD(3)(1:24)//'INX'
      INXQUAD(4) = MAPQUAD(4)(1:24)//'INX'
C
C     *** UNIT FILES FOR MAP AND INDEX FILES
C
      IMAPFILE = 90
      INXFILE  = 80
C
C     *** OPEN FILES: MAP AND INDEX FILES
C
      DO 600 K = 1,4 
         IMPUNIT  = IMAPFILE + K
         INDXUNIT = INXFILE + K
         OPEN(INDXUNIT,FILE=INXQUAD(K),ACCESS='DIRECT',
     +       FORM='UNFORMATTED',STATUS='UNKNOWN',RECL=24,IOSTAT=IOCHK)
         OPEN(IMPUNIT,FILE=MAPQUAD(K),ACCESS='DIRECT',
     +        FORM='UNFORMATTED',STATUS='UNKNOWN',RECL=512,IOSTAT=IOCHK)
 600  CONTINUE
C
      RETURN
      END

*******************************************************************************
$PAGE 
      SUBROUTINE RMMINMAX(LONREAL,LATREAL,XLONMIN,XLONMAX,YLATMIN,
     +           YLATMAX)
C
C     ROUTINE FINDS THE MIN AND MAX OF THE LONGITUDE AND LATITUDE COORDINATES
C     FOR AN ENTIRE LINE SEGMENTS DEFINED
C
      REAL*4    LONREAL,LATREAL
C
C     *** DETERMINE MINIMUM AND MAXIMUM LON/LAT COORDINATES OF MAP
C
      IF (LONREAL.LT.XLONMIN) XLONMIN = LONREAL
      IF (LONREAL.GT.XLONMAX) XLONMAX = LONREAL
      IF (LATREAL.LT.YLATMIN) YLATMIN = LATREAL
      IF (LATREAL.GT.YLATMAX) YLATMAX = LATREAL
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMMESSGE(CODE,LINE,LATLON,ERRTXT,MSGFILE,RTNFLG)
C
C     ROUTINE DISPLAYS THE MESSAGE ON SCREEN AND WRITE INTO A FILE
C 
      INTEGER*2     LINE,CODE
      CHARACTER*1   RTNFLG,RTNCODE
      CHARACTER*2   INCHAR
      CHARACTER*5   OUTMSG
      CHARACTER*20  MESSAG(6)
      CHARACTER*85  MSGLIN,WRTMESSG
      CHARACTER*24  LATLON
      CHARACTER*40  MSGFILE,ERRTXT,MESGTXT
C
C     *** GETS MESSAGE TO BE DISPLAYED ON SCREEN
C
      MESGTXT = ERRTXT
      CALL GETMSG(624,MSGLIN)
      CALL GETMSG(999,MSGLIN)
      CALL PARSE1(MSGLIN,78,6,20,MESSAG,RTNCODE)
      MSGLIN = ' '
      MSGLIN(1:)=MESSAG(1)
      LGTH1=LNG(MSGLIN)+1
      IF (CODE.EQ.0) THEN
         MSGLIN(LGTH1+6:)=MESSAG(4)
         LGTH2=LNG(MSGLIN)+1
         CALL LOCATE(16,0,IERR)
         CALL WRTSTR(MSGLIN,LGTH2,14,0)
      ELSE IF (CODE.EQ.1) THEN
         MSGLIN(LGTH1+6:)=MESSAG(2)
         LGTH2=LNG(MSGLIN)
         MSGLIN(LGTH2+25:)=MESSAG(3)
         LGTH3=LNG(MSGLIN)+1
         CALL LOCATE(16,0,IERR)
         CALL WRTSTR(MSGLIN,LGTH3,14,0)
      ELSE IF (CODE.EQ.2) THEN
         MSGLIN(LGTH1+6:)=MESSAG(5)
         LGTH2=LNG(MSGLIN)+1
         MSGLIN(LGTH2+25:)=MESSAG(3)
         LGTH3=LNG(MSGLIN)+1
         CALL LOCATE(16,0,IERR)
         CALL WRTSTR(MSGLIN,LGTH3,14,0)
      ELSE IF (CODE.EQ.3) THEN
         MSGLIN(LGTH1+6:)=MESSAG(6)
         LGTH2=LNG(MSGLIN)+1
         MSGLIN(LGTH2+25:)=MESSAG(3)
         LGTH3=LNG(MSGLIN)+1
         CALL LOCATE(16,0,IERR)
         CALL WRTSTR(MSGLIN,LGTH3,14,0)
      END IF
C
C     *** WRITE ERROR MESSAGE TO SCREEN            
C
      OUTMSG(4:4) = CHAR(0)
      WRITE(OUTMSG(1:4),'(I4)') LINE
      CALL LOCATE(16,LGTH1,IERR)         
      CALL CWRITE(OUTMSG,12,IERR)
      IF (CODE.EQ.0) THEN
         CALL LOCATE(16,LGTH2,IERR)         
         ERRTXT(32:32) = CHAR(0)
         CALL CWRITE(ERRTXT,12,IERR)
      ELSE
         CALL LOCATE(16,LGTH2,IERR)         
         LATLON(24:24) = CHAR(0)
         CALL CWRITE(LATLON,12,IERR)
         CALL LOCATE(16,LGTH3,IERR)         
         ERRTXT(31:31) = CHAR(0)
         CALL CWRITE(ERRTXT,12,IERR)
      END IF
C
C     *** WRITE MESSAGE TO FILE
C
      IF (CODE.EQ.0) THEN
         WRITE(WRTMESSG,450)MESSAG(1),LINE,MESSAG(4),ERRTXT
      ELSE IF (CODE.EQ.1) THEN
         WRITE(WRTMESSG,460)MESSAG(1),LINE,MESSAG(2),LATLON,MESSAG(3),
     +                     MESGTXT
      ELSE IF (CODE.EQ.2) THEN
         WRITE(WRTMESSG,470)MESSAG(1),LINE,MESSAG(5),LATLON,MESSAG(3),
     +                     ERRTXT
      ELSE IF (CODE.EQ.3) THEN
         WRITE(WRTMESSG,470)MESSAG(1),LINE,MESSAG(6),LATLON,MESSAG(3),
     +                     ERRTXT
      END IF
      WRITE(71,'(A85)')WRTMESSG
C
      CALL LOCATE(17,0,IERR)
      CALL WRTMSG(7,623,12,0,0,MSGFILE,30)
      CALL WRTMSG(6,507,12,1,0,' ',0)
      CALL GETCHAR(0,INCHAR)
      CALL CLRMSG(9)
      CALL CLRMSG(7)
      CALL CLRMSG(6)
      IF (INCHAR.EQ.'ES'.OR.INCHAR.EQ.'4F') THEN
         RTNFLG = '3'
      ELSE
         RTNFLG = '0'
      END IF
C
      RETURN
C
C     *** FORMAT STATEMENTS
C
 450  FORMAT(A5,I4,1X,A22,1X,A31)
 460  FORMAT(A5,I4,1X,A8,A23,1X,A6,1X,A34)
 470  FORMAT(A5,I4,1X,A10,1X,A20,1X,A6,1X,A25)
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMCKAREA(ILATDEG,ILATMIN,ILATSEC,ILONDEG,ILONMIN,
     +               ILONSEC,LATREAL,LONREAL,AREA,ENDSEG,PRVAREA,
     +               NLATREAL,NLONREAL,MILATDEG,MILONDEG,MPUNIT,
     +               INXUNIT,NTIMES,FOUND,FIRST,MSGNUM,MSGFILE,
     +               LINENUM,RTNFLG,RTNMSG,LATSIGN,LONSIGN)
C
C     ROUTINE USES TO CHECK WHICH AREA USER DEFINES THE LINE SEGMENT
C
      REAL*4       LATREAL,LONREAL,NLATREAL(128),NLONREAL(128)
      INTEGER*2    ILATDEG,ILONDEG,LINENUM
      INTEGER*2    MPUNIT(4),INXUNIT(4),AREA,PRVAREA,NTIMES
      INTEGER*2    MILONDEG(128),MILATDEG(128),TEMPAREA
      INTEGER*2    LATSIGN,LONSIGN
      CHARACTER*1  RTNFLG
      CHARACTER*24 MIXDATA
      CHARACTER*40 MSGFILE,MSGNUM(3)
      LOGICAL      FOUND,ENDSEG,OLDENDSG,FINDAREA,FIRST,CURRAREA
      LOGICAL      ERRLAT,ERRLON,RTNMSG
C
      FOUND    = .FALSE.
      IMAPFILE = 90
      INXFILE  = 80
C
      IF (ILATDEG.EQ.99.AND.ILONDEG.EQ.99) THEN
         GO TO 200
      END IF
      IF (LATREAL.NE.0.0) THEN
         ILTSIGN = SIGN(1,LATREAL)
         IF (LATSIGN.EQ.0) THEN
             LATSIGN = ILTSIGN
         ELSE
            IF (LATSIGN.EQ.ILTSIGN) THEN
               ERRLAT = .FALSE.
            ELSE
               ERRLAT = .TRUE.
            END IF
         END IF       
      ELSE
         ERRLAT = .FALSE.
      END IF
C
      IF (LONREAL.NE.0.0) THEN
         ILNSIGN = SIGN(1,LONREAL)
         IF (LONSIGN.EQ.0) THEN
            LONSIGN = ILNSIGN
         ELSE
            IF (LONSIGN.EQ.ILNSIGN) THEN
               ERRLON = .FALSE.
            ELSE
               ERRLON = .TRUE.
            END IF
         END IF       
      ELSE
         ERRLON = .FALSE.
      END IF
C
C     *** MAKE SURE LON/LAT VALUES ARE NOT MIXED WITHIN LINE SEGMENT
C
      IF (.NOT.OLDENDSG) THEN
         IF (ERRLAT.OR.ERRLON) THEN
            RTNMSG = .TRUE.
            WRITE(MIXDATA,165)ILATDEG,ILATMIN,ILATSEC,' /',
     +            ILONDEG,ILONMIN,ILONSEC
 165        FORMAT(I3,I3,I3,A2,I4,1X,I3,1X,I3)
            CALL RMMESSGE(1,LINENUM,MIXDATA,MSGNUM(1),MSGFILE,RTNFLG)
         GO TO 220
         END IF
      END IF
 200  CONTINUE
C
C     *** STORE ALL LATITUDE AND LONGITUDE IN TEMPORARY ARRAY FOR FINDING
C         THE QUADRANT WHICH USER IS WORKING ON IT.
C
      NTIMES  = NTIMES + 1
      NLONREAL(NTIMES) = LONREAL
      NLATREAL(NTIMES) = LATREAL
      MILONDEG(NTIMES) = ILONDEG
      MILATDEG(NTIMES) = ILATDEG
C
      IF (LONREAL.NE.0.0.AND.LATREAL.NE.0.0) THEN
         IF (LONREAL.GT.-180.0.AND.LONREAL.LT.0.0) THEN
            IF (LATREAL.GT.0.0.AND.LATREAL.LT.90.) THEN
               AREA = 1
            ELSE IF (LATREAL.GT.-90.0.AND.LATREAL.LT.0.0) THEN
               AREA = 2
            END IF
         ELSE IF (LONREAL.GT.0.0.AND.LONREAL.LT.180.0) THEN
            IF (LATREAL.GT.0.0.AND.LATREAL.LT.90.) THEN
               AREA = 3
            ELSE IF (LATREAL.GT.-90.0.AND.LATREAL.LT.0.0) THEN
               AREA = 4
            END IF
         END IF
         FIRST = .FALSE.
         CURRAREA = .FALSE.
         FINDAREA = .TRUE.
      END IF
C
      IF (LONREAL.EQ.0.0.AND.LATREAL.NE.0.0) THEN
         IF (LATREAL.GT.0.0.AND.LATREAL.LT.90.) THEN
            IF (FINDAREA) THEN
               AREA = PRVAREA
               CURRAREA = .FALSE.
            ELSE
               TEMPAREA = 3
               FINDAREA = .FALSE.
               CURRAREA = .TRUE.
            END IF
         ELSE IF (LATREAL.GT.-90.0.AND.LATREAL.LT.0.0) THEN
            IF (FINDAREA) THEN
               AREA = PRVAREA
               CURRAREA = .FALSE.
            ELSE
               TEMPAREA = 2
               FINDAREA = .FALSE.
               CURRAREA = .TRUE.
            END IF
         END IF
         FIRST = .FALSE.
      ELSE IF (LATREAL.EQ.0.0.AND.LONREAL.NE.0.0) THEN
         IF (LONREAL.GT.-180.0.AND.LONREAL.LT.0.0) THEN
            IF (FINDAREA) THEN
               AREA = PRVAREA
               CURRAREA = .FALSE.
            ELSE
               TEMPAREA = 2    
               FINDAREA = .FALSE.
               CURRAREA = .TRUE.
            END IF
         ELSE IF (LONREAL.GT.0.0.AND.LONREAL.LT.180.0) THEN
            IF (FINDAREA) THEN
               AREA = PRVAREA
               CURRAREA = .FALSE.
            ELSE
               TEMPAREA = 3
               FINDAREA = .FALSE.
               CURRAREA = .TRUE.
            END IF
         END IF
         FIRST = .FALSE.
      END IF
C
      IF (LONREAL.EQ.0.0.AND.LATREAL.EQ.0.0) THEN
         IF (FINDAREA) THEN 
            AREA = PRVAREA
            CURRAREA = .FALSE.
         ELSE IF (FIRST) THEN
            TEMPAREA = 3
            CURRAREA = .TRUE.
            FINDAREA = .FALSE.
         ELSE IF (CURRAREA) THEN
            TEMPAREA = TEMPAREA
            FINDAREA = .FALSE.
            CURRAREA = .FALSE.
         END IF
         FIRST = .FALSE.
      END IF
      IF (ENDSEG) THEN
         IF (FINDAREA) THEN
            AREA = PRVAREA
         ELSE
            AREA = TEMPAREA
         END IF
         FIRST = .TRUE.
         LATSIGN = 0
         LONSIGN = 0
         FOUND    = .TRUE.
         FINDAREA = .FALSE.
         CURRAREA = .FALSE.
      END IF
      MPUNIT(AREA) = IMAPFILE + AREA
      INXUNIT(AREA)= INXFILE + AREA
C
 220  CONTINUE
      ERRLAT = .FALSE.
      ERRLON = .FALSE.
      OLDENDSG = ENDSEG
      PRVAREA = AREA
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMRSTORE(MAPTYPE)
C
C     ROUTINE RESTORES THE ORIGINAL POINTER FILE (*.FLE) AND DELETE ALL
C     DEFINED MAP AND INDEX FILES (RPCLMP??.*) DEPENDENT ON THE MAPTYPE WHICH
C     USER SELECTED, IF THE INPUT DATA FILE IS EMPTY OR USER TRIES TO RUN THE
C     PROGRAM AGAIN.  THIS WAY THE MAP, INDEX AND POINTER FILES WILL NOT
C     CONTENT THE OLD DATA.
C
      CHARACTER*40 FILEMAP,FILEPTER,ALLMPFLE
      CHARACTER*78 LINETXT,ORGFILE
      INTEGER*2    SYSTEM,MAPTYPE
      LOGICAL      FILEFLG
C
      LINETXT = ' '
      ORGFILE = ' '
      DELFILE = ' '
C
C     RESTORE THE ORGINAL FILES DEPENDENT ON THE MAPTYPE SELECTED
C
      IF (MAPTYPE.EQ.1) THEN
         FILEMAP = 'O:\MAP\CLICMAP\RPCLMPC1.CST'
         ALLMPFLE= 'O:\MAP\CLICMAP\RPCLMPC?.*'
         FILEPTER= 'O:\MAP\COAST.ORG'
      ELSE IF (MAPTYPE.EQ.2) THEN
         FILEMAP = 'O:\MAP\CLICMAP\RPCLMPR1.RIV'
         ALLMPFLE= 'O:\MAP\CLICMAP\RPCLMPR?.*'
         FILEPTER= 'O:\MAP\RIVERS.ORG'
      ELSE IF(MAPTYPE.EQ.3) THEN
         FILEMAP = 'O:\MAP\CLICMAP\RPCLMPB1.BDY'
         ALLMPFLE= 'O:\MAP\CLICMAP\RPCLMPB?.*'
         FILEPTER= 'O:\MAP\BOUNDARY.ORG'
      ELSE IF (MAPTYPE.EQ.4) THEN
         FILEMAP = 'O:\MAP\CLICMAP\RPCLMPL1.LAK'
         ALLMPFLE= 'O:\MAP\CLICMAP\RPCLMPL?.*'
         FILEPTER= 'O:\MAP\LAKES.ORG'
      ELSE IF (MAPTYPE.EQ.5) THEN
         FILEMAP = 'O:\MAP\CLICMAP\RPCLMPS1.STS'
         ALLMPFLE= 'O:\MAP\CLICMAP\RPCLMPS?.*'
         FILEPTER= 'O:\MAP\STATES.ORG'
      END IF
C
C     *** COPY THE ORIGINAL PIONTER FILES (*.ORG) TO (*.FLE)
C
      INQUIRE(FILE=FILEPTER,EXIST=FILEFLG)
      IF (FILEFLG) THEN
         WRITE(ORGFILE,550)FILEPTER
 550     FORMAT('COPY ',A30,1X,'O:\MAP\*.FLE >> NUL')
         LGTH = LNG(ORGFILE)+1
         ORGFILE(LGTH:LGTH) = CHAR(0)
         I = SYSTEM(ORGFILE)
      END IF
C
C     *** DELETE ALL DEFINED MAP FILES THAT USER SELECTED
C
      INQUIRE(FILE=FILEMAP,EXIST=FILEFLG)
      IF (FILEFLG) THEN
         WRITE(LINETXT,750)ALLMPFLE
 750     FORMAT('DEL ',A30,1X,'>> NUL')
         LGTH = LNG(LINETXT)+1
         LINETXT(LGTH:LGTH) = CHAR(0)
         I = SYSTEM(LINETXT)
      END IF
      CLOSE(14)
      CLOSE(15)
      RETURN
      END 

*******************************************************************************
$PAGE
      SUBROUTINE RMCLOSEF
C
C     ROUTINE USES TO CLOSE ALL FILES
C
      CLOSE(12)
      CLOSE(61)
      CLOSE(62)
      CLOSE(63)
      CLOSE(71)
      CLOSE(72) 
      CLOSE(81)
      CLOSE(82)
      CLOSE(83)
      CLOSE(84)
      CLOSE(91)
      CLOSE(92)
      CLOSE(93)
      CLOSE(94)
      RETURN
      END 
 
*******************************************************************************
$PAGE
      SUBROUTINE RMLNSGFL(ITYPE,LNSGFILE,LNSGSAVE,ERRORMSG)
C
C     ROUTINE USES TO SELECT THE INPUT DATA FILE ACCORDING TO THE MAP TYPE
C
      CHARACTER*40 LNSGFILE,LNSGSAVE
      CHARACTER*20 ERRORMSG
      INTEGER*2    ITYPE
C
      IF (ITYPE.EQ.1) THEN
         LNSGFILE   = 'O:\MAP\CLICMAP\COAST.SEG'
         LNSGSAVE   = 'O:\MAP\CLICMAP\COAST.SAV'
         ERRORMSG   = 'COASTLINES'
      ELSE IF (ITYPE.EQ.2) THEN
         LNSGFILE   = 'O:\MAP\CLICMAP\RIVERS.SEG'
         LNSGSAVE   = 'O:\MAP\CLICMAP\RIVERS.SAV'
         ERRORMSG   = 'RIVERS'
      ELSE IF(ITYPE.EQ.3) THEN
         LNSGFILE   = 'O:\MAP\CLICMAP\BORDERS.SEG'
         LNSGSAVE   = 'O:\MAP\CLICMAP\BORDERS.SAV'
         ERRORMSG   = 'BORDERS'
      ELSE IF (ITYPE.EQ.4) THEN
         LNSGFILE   = 'O:\MAP\CLICMAP\LAKES.SEG'
         LNSGSAVE   = 'O:\MAP\CLICMAP\LAKES.SAV'
         ERRORMSG   = 'LAKES ISLANDS'
      ELSE IF (ITYPE.EQ.5) THEN
         LNSGFILE   = 'O:\MAP\CLICMAP\STATES.SEG'
         LNSGSAVE   = 'O:\MAP\CLICMAP\STATES.SAV'
         ERRORMSG   = 'STATES'
      END IF
C
      RETURN
      END      

*******************************************************************************
$PAGE
      SUBROUTINE RMMODFLE(LNSGFILE,ERRORMSG)
C
C     ROUTINE USES TO WRITE THE NAME OF LEVEL OF MAP DETAIL SELECTED TO THE
C     INPUT DATA FILE
C
      CHARACTER*80 LNSGTXT(34)
      CHARACTER*40 LNSGFILE
      CHARACTER*20 ERRORMSG
      CHARACTER*6  OUTFRM
C
 700  CONTINUE
      OPEN(62,FILE=LNSGFILE,STATUS='OLD',FORM='FORMATTED',
     +        IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(LNSGFILE,'   REPLMAP   ',IOCHK)
         GO TO 700
      END IF
C
      DO 750 I = 1,34
         READ(62,'(A80)',END=770)LNSGTXT(I)
 750  CONTINUE
C
 770  CONTINUE
      DO 780 J = 1,34
         IF (LNSGTXT(J)(1:6).EQ.'PLEASE') THEN
            LGTH = LNG(LNSGTXT(J))
            LNSGTXT(J) = LNSGTXT(J)(1:LGTH+2)//ERRORMSG
         END IF
 780  CONTINUE
C
      REWIND 62
      DO 790 I = 1,34
         CALL GETFRMT(LNSGTXT(I),OUTFRM)
         WRITE(62,OUTFRM)LNSGTXT(I)
  790 CONTINUE
      CLOSE(62)
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMRVALUE(ILATDEG,ILATMIN,ILATSEC,ILONDEG,ILONMIN,
     +                   ILONSEC,NEGLAT,NEGLON,RTNERR)
C
C     ROUTINE READS THE INPUT DATA FILE AND MAKE SURE ALL VALUES ARE VALIDS
C
      INTEGER*2    ILATDEG,ILATMIN,ILATSEC
      INTEGER*2    ILONDEG,ILONMIN,ILONSEC
      CHARACTER*1  RTNERR
      CHARACTER*80 RDLATLON,INPUTVAL,BLANK
      LOGICAL      NEGLAT,NEGLON
      DATA         BLANK /'          '/
C
C     *** INITIALIZE
C
      NEGLAT   = .FALSE.
      NEGLON   = .FALSE.
      INPUTVAL = BLANK
      RDLATLON = BLANK
      RTNERR   = '0'
C
      READ(61,'(A80)',END=131)INPUTVAL
      IF (INPUTVAL.EQ.' ') THEN
         RTNERR = '3'
         GO TO 111
      END IF
      DO 80 KK = 1 , 80
         IF (INPUTVAL(1:KK).NE.' ') THEN
           KOUNT = KK
           RDLATLON = INPUTVAL(KOUNT:)
           GO TO 81
         END IF
 80   CONTINUE
 81   CONTINUE
      LNGTH = LNG(RDLATLON)
      DO 90 I = 1,LNGTH
         IF (RDLATLON(I:I).EQ.' ') THEN
            IF (RDLATLON(1:1).EQ.'-') THEN
               NEGLAT = .TRUE.
               IF (RDLATLON(2:2).EQ.' '.OR.RDLATLON(2:2).EQ.'-') THEN
                  GO TO 151
               END IF
            END IF
            READ(RDLATLON(1:I),'(I4)',ERR=151)ILATDEG
            J = I + 1
            GO TO 91
         END IF
 90   CONTINUE
 91   CONTINUE
      IF (J.EQ.LNGTH.OR.J.EQ.0) GO TO 151
      DO 92 I = J,LNGTH 
         IF (RDLATLON(J:I).NE.' ') THEN
            J1 = I
            GO TO 93
         END IF
 92   CONTINUE
 93   CONTINUE
      IF (J1.EQ.LNGTH) GO TO 151
      DO 94 I = J1,LNGTH 
         IF (RDLATLON(I:I).EQ.' ') THEN
            READ(RDLATLON(J1:I),'(I3)',ERR=151)ILATMIN
            K = I
            GO TO 95
         END IF
 94   CONTINUE
 95   CONTINUE
      IF (K.EQ.LNGTH) GO TO 151
      DO 96 I = K,LNGTH 
         IF (RDLATLON(K:I).NE.' ') THEN
            K1 = I
            GO TO 97
         END IF
 96   CONTINUE
 97   CONTINUE
      IF (K1.EQ.LNGTH) GO TO 151
      DO 98 I = K1,LNGTH
         IF (RDLATLON(I:I).EQ.' ') THEN
            READ(RDLATLON(K1:I),'(I2)',ERR=151)ILATSEC
            L = I
            GO TO 99
         END IF
 98   CONTINUE
 99   CONTINUE
      IF (L.EQ.LNGTH) GO TO 151
      DO 100 I = L,LNGTH 
         IF (RDLATLON(L:I).NE.' ') THEN
            L1 = I
            GO TO 101
         END IF
 100  CONTINUE
 101  CONTINUE
      IF (L1.EQ.LNGTH) GO TO 151
      DO 102 I = L1,LNGTH
         IF (RDLATLON(I:I).EQ.' ') THEN
            IF (RDLATLON(L1:L1).EQ.'-') THEN
               NEGLON = .TRUE.
               IF (RDLATLON(L1+1:L1+1).EQ.' '.OR.
     +             RDLATLON(L1+1:L1+1).EQ.'-') THEN
                 GO TO 151
               END IF
            END IF
            READ(RDLATLON(L1:I),'(I4)',ERR=151)ILONDEG
            M = I
            GO TO 103
         END IF
 102  CONTINUE
 103  CONTINUE
      IF (M.EQ.LNGTH) GO TO 151
      DO 104 I = M,LNGTH 
         IF (RDLATLON(M:I).NE.' ') THEN
            M1 = I
            GO TO 105
         END IF
 104  CONTINUE
 105  CONTINUE
      IF (M1.EQ.LNGTH) GO TO 151
      DO 106 I = M1 ,LNGTH
         IF (RDLATLON(I:I).EQ.' ') THEN
            READ(RDLATLON(M1:I),'(I3)',ERR=151)ILONMIN
            N = I
            GO TO 107
         END IF
 106  CONTINUE
 107  CONTINUE
      IF (N.EQ.LNGTH) GO TO 151
      DO 108 I = N,LNGTH 
         IF (RDLATLON(N:I).NE.' ') THEN
            N1 = I
            GO TO 109
         END IF
 108  CONTINUE
 109  CONTINUE
      DO 110 I = N1 ,LNGTH
         READ(RDLATLON(N1:I),'(I2)',ERR=151)ILONSEC
 110  CONTINUE
 111  CONTINUE
      RETURN
C
C     *** END OF INPUT FILE
C
 131  CONTINUE
      RTNERR = '1'
      RETURN
C
C     *** ERROR READING O:\MAP\CLICMAP\LINESEG.SEG FILE ***
C  
 151  CONTINUE
      RTNERR = '2'
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMWRTMPT(PTFILE,TMPFILE,MSGFILE,RTNFLG)
C
C     ROUTINE COPIES THE MAP PONITER FILE TO TEMPORARY FILE AND REWRITE THE
C     MAP POINTER FILE WITH LINES THAT USES FOR DISPLAYING THE REPLACEMENT MAP
C
      CHARACTER*1  RTNFLG
      CHARACTER*6  OUTFRM
      CHARACTER*40 PTFILE,TMPFILE,MSGFILE
      CHARACTER*72 LTEXT(60),TEXT,BLANK
      DATA         BLANK /'       '/
C
C     OPEN THE TEMPORARY MAP POINTER FILE
C
      OPEN(63,FILE=TMPFILE,STATUS='UNKNOWN',FORM='FORMATTED')
C
C     COPY THE MAP POINTER FILE TO TEMPORARY FILE
C
      CALL RMSAVEFL(PTFILE,TMPFILE)
C
C     *** OPENS THE MAP POINTER FILE: COAST.FLE, RIVERS.FLE,... ETC
C
      KLINE  = 0
      KCOUNT = 1
      DO 620 I = 1,60
         LTEXT(I) = BLANK
 620  CONTINUE
C
C     OPEN THE MAP POINTER FILE AND REWRITE IT WITH WHICH UPDATED LINES
C
 630  CONTINUE
      OPEN(12,FILE=PTFILE,STATUS='OLD',FORM='FORMATTED',IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(PTFILE,'   REPLMAP      ',IOCHK)
         GO TO 630
      END IF
C
 650  CONTINUE
      REWIND(12)
      READ(12,*,END=900,ERR=900)NLINE
C
C     REWRITE MAP POINTER FILE THAT HAS BEEN UPDATED
C
      DO 660 L = 1,NLINE
         READ(12,'(A72)',END=660,ERR=900) TEXT
         IF (TEXT(8:14).EQ.'CLICMAP') THEN
            KLINE = KLINE + 1
            KCOUNT = KCOUNT + 1
            LTEXT(KCOUNT) = TEXT
            KCOUNT = KCOUNT + 1
            READ(12,'(A72)',END=660,ERR=900) LTEXT(KCOUNT)
            KCOUNT = KCOUNT + 1
            READ(12,'(A72)',END=660,ERR=900) LTEXT(KCOUNT)
         ELSE
            READ(12,*,END=660,ERR=900)
            READ(12,*,END=660,ERR=900)
         END IF
         TEXT = BLANK
 660  CONTINUE
C
      IF (KLINE.GT.0) THEN
         WRITE(LTEXT(1),'(I2)')KLINE
         REWIND(12)
         NUMLINE = KLINE * 3 + 1
         DO 670 I = 1, NUMLINE
             CALL GETFRMT(LTEXT(I),OUTFRM)
             WRITE(12,OUTFRM) LTEXT(I)            
 670     CONTINUE
      END IF
      CLOSE(12)
      RETURN
C
C     *** ERROR READING THE POINTER FILE \CLIGRAF\MAP\*.FLE
C
 900  CONTINUE
      CALL RMMESSGE(0,KLINE,' ',PTFILE,MSGFILE,RTNFLG)
      RETURN
      END

*******************************************************************************
$PAGE
      SUBROUTINE RMDTLMAP(RWCODE,ITYPE,YLATMIN,YLATMAX,XLONMIN,XLONMAX,
     +                    EMPTYFLE,RTNFLG,FLAGMAP,MSGFILE)
C
C     ROUTINE USES TO STORE THE MIN AND MAX OF LAT/LON VALUES AND CHECK FOR
C     ALL DETAIL OF MAP THAT INDICATES THE TYPE OF MAP WHICH ALREADY DEFINED.
C     IF THE TYPE OF MAP HAS NOT BEEN DEFINED, IT SET TO FALSE.
C
C     NOTE :
C            RWCODE = 1 ----> READ AND WRITE THE DETAILMP.RMP FILE
C            RWCODE = 0 ----> READ ONLY THE DETAILMP.RMP FILE AND RETURN FLAGS
C                             THAT INDICATED THE MAP HAS NOT DEFINED
C
      CHARACTER*40  DTLMPF,MSGFILE
      CHARACTER*1   RTNFLG
      REAL*4        YLATMIN,YLATMAX,XLONMIN,XLONMAX
      REAL*4        MNLAT,MXLAT,MNLON,MXLON
      REAL*4        LATMNY(5),LATMXY(5),LONMNX(5),LONMXX(5)
      INTEGER*2     ITYPE,RWCODE,FLAG(5)
      LOGICAL       EMPTYFLE,FLAGMAP(5)
C
      ILINE = 1
      MNLAT  =  999.0
      MXLAT  = -999.0
      MNLON  =  999.0
      MXLON  = -999.0
      DTLMPF = 'O:\MAP\CLICMAP\DETAILMP.RMP'
 810  CONTINUE
      OPEN(66,FILE=DTLMPF,STATUS='OLD',FORM='FORMATTED',IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(DTLMPF,'  REPLMAP      ',IOCHK)
         GO TO 810
      END IF
C
      READ(66,*,ERR=920,END=870)NLINE
      DO 830 I = 1, NLINE
         ILINE = ILINE + 1
         READ(66,*,ERR=920,END=870)FLAG(I),LATMNY(I),LATMXY(I),
     +                             LONMNX(I),LONMXX(I)
         FLAGMAP(I) = .TRUE.
 830  CONTINUE
      REWIND(66)
      IF (RWCODE.EQ.1) THEN
         IF (.NOT.EMPTYFLE) THEN
            FLAG(ITYPE)   = 1
            LATMNY(ITYPE) = YLATMIN
            LATMXY(ITYPE) = YLATMAX
            LONMNX(ITYPE) = XLONMIN
            LONMXX(ITYPE) = XLONMAX
         ELSE 
            FLAG(ITYPE)   = 0
            LATMNY(ITYPE) = MNLAT
            LATMXY(ITYPE) = MXLAT
            LONMNX(ITYPE) = MNLON
            LONMXX(ITYPE) = MXLON
         END IF
C
C     *** WRITE TO THE O:\CLIGRAF\MAP\CLICMAP\DETAILMP.RMP TO KEEP TRACK THE
C         MIN AND MAX OF ALL REPLACEMENT DEFINED
C
         WRITE(66,'(I2)')NLINE
         DO 840 K = 1, NLINE
            WRITE(66,845)FLAG(K),LATMNY(K),LATMXY(K),
     +                           LONMNX(K),LONMXX(K)
 840     CONTINUE
 845     FORMAT(I1,','4(F8.3,','))
      IF (EMPTYFLE) GOTO 870
C
C     *** CHECKING THE TYPE OF MAP ARLEADY DEFINED OR NOT
C
      ELSE IF (RWCODE.EQ.0) THEN
         DO 850 L = 1, NLINE
            IF (FLAG(L).EQ.0) THEN
               FLAGMAP(L) = .FALSE.
            ELSE
               FLAGMAP(L) = .TRUE.
            END IF
 850     CONTINUE
      END IF
C
C     *** DETERMINES MIN AND MAX OF LON/LAT VALUES FOR ALL DETAIL MAP FILES
C
      DO 860 J = 1, NLINE
         MNLON = AMIN1(MNLON,LONMNX(J))
         MXLON = AMAX1(MXLON,LONMXX(J))
         MNLAT = AMIN1(MNLAT,LATMNY(J))
         MXLAT = AMAX1(MXLAT,LATMXY(J))
 860  CONTINUE
      YLATMIN = MNLAT
      YLATMAX = MXLAT
      XLONMIN = MNLON
      XLONMAX = MXLON
 870  CONTINUE
      CLOSE(66)
      RETURN
C
C     *** ERROR READING O:\MAP\CLICMAP\DETAILMP.RMP FILE ***
C  
 920  CONTINUE
      CALL RMMESSGE(0,ILINE,' ',DTLMPF,MSGFILE,RTNFLG)
      RETURN
      END
