$STORAGE:2
      PROGRAM SORTRDR
C
C   ROUTINE TO REARRANGE THE RDRRAAAA.DBM FILE SO THAT THE FORMS ARE IN
C   THE ORDER AS THEY WERE IN CLICOM VERSION 2.1
C      
      CHARACTER*1  NULL
      CHARACTER*3  DEVER
      CHARACTER*20 INFRM2,INFRM4,DEFORM(37)
      CHARACTER*51 HLDRC2(500), INREC2
      CHARACTER*55 HLDRC4(500), INREC4
      INTEGER*2    CUSTOMPTR, FORMSEQ(500), HEADR2, HEADR4
      EQUIVALENCE  (HEADR2,INREC2(1:2)), (INFRM2,INREC2(3:22))
      EQUIVALENCE  (HEADR4,INREC4(1:2)), (INFRM4,INREC4(3:22))
C
      DATA DEFORM /'Dictionary','MONTHLY DATA','TEN DAY DATA',
     +    'DAILY DATA','SYNOPTIC DATA','HOURLY DATA',
     +    'FIFTEEN MINUTE DATA','UPPER-AIR DATA','Daily Means/Extremes',
     +    'Means/Extremes (10D)','INV-DAILY','INV-HOURLY','INV-U-A',
     +    'STN GEOGRAPHY','STN OBSERVATION','STN ELEMENT',
     +    'STN ELEMENT EXTREMES','DATASET DIRECTORY',
     +    'DATASET INFORMATION','ELEMENT DEFINITION','DATASET ELEMENT',
     +    'DATASET RECORD','DATASET RECORD FIELD','FIELD DEFINITION',
     +    'MISC CODE DEFINITION','H MLY DATA','H 10D DATA','H DLY DATA',
     +    'H SYN DATA','H HLY DATA','H 15M DATA','H U-A DATA',
     +    'STN GEOG UP','STN OBS UP','STN ELEM UP','VIEW FIELD DEFS',
     +    'NORMALS'/, FORMSEQ/500*0/
C 
C    DETERMINE WHICH VERSION OF DATAEASE IS IN USE
C
      NULL = CHAR(0)
      CUSTOMPTR = 37
      CALL GETDEASE(DEVER)
      IF (DEVER.EQ.'4.0') THEN
         GOTO 500
      END IF
C *****************************************************************************
C *                     CODE FOR DATAEASE 2.5
C *****************************************************************************
C
C   OPEN THE OLD AND NEW RDRRAAAA.DBM FILES
C
      OPEN (71,FILE='Q:RDRRAAAA.OLD',STATUS='OLD',FORM='BINARY'
     +     ,IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         CALL BADMSG(1,IOCHK)
         STOP 3
      ENDIF   
      OPEN (22,FILE='Q:RDRRAAAA.DBM',STATUS='NEW',FORM='BINARY'
     +     ,IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         CALL BADMSG(2,IOCHK)
         STOP 4
      ENDIF        
C
C     READ ALL THE ENTRIES FROM THE RDR FILE INTO THE HOLDING ARRAY
C
      DO 310 I = 1,500
         READ(71,ERR=715,END=320) HLDRC2(I)
  310 CONTINUE
      GO TO 725
  320 NUMFORMS = I - 1
C
C     SORT THE DATAEASE FORMS BY BUILDING AN ARRAY OF RECORD NUMBERS IN THE 
C     ORDER WANTED. START AT FORM #9 (1ST 8 ARE SYSTEM FORMS, DO NOT MOVE)
C     AND SEE IF THE FORM MATCHES ONE OF THE CLICOM FORM NAMES.  PUT THAT
C     RECORD NUMBER IN THE NEXT SLOT OF THE POINTER ARRAY, FORMSEQ. IF THE
C     FORM DOES NOT MATCH A CLICOM FORM, IT IS A USER-DEFINED FORM AND IS
C     PUT IN THE 1ST AVAILABLE SLOT AFTER THE CLICOM FORMS.
C
      DO 390 L = 9,NUMFORMS
         INREC2 = HLDRC2(L)
C---     RECORD TYPE 13,15 ARE DELETED ENTRIES IN RDRRAAAA. PUT AT END OF FORMS
         IF (HEADR2.EQ.13 .OR. HEADR2.EQ.15) GOTO 380
         DO 340 J = 1,20
            IF (INFRM2(J:J).EQ.NULL) THEN
                INFRM2(J:J) = ' '
            ENDIF
  340    CONTINUE               
         DO 370 K = 1,37
            IF (INFRM2 .EQ. DEFORM(K)) THEN         
               FORMSEQ(K) = L
               GO TO 390
            ENDIF
  370    CONTINUE
  380    CUSTOMPTR = CUSTOMPTR + 1
         FORMSEQ(CUSTOMPTR) = L
  390 CONTINUE
C              
C   WRITE OUT THE RDRRAAAA ENTRIES IN THE NEW ORDER
C
  400 CONTINUE
      DO 410 I = 1,8
         WRITE(22) HLDRC2(I)          
  410 CONTINUE
      DO 420 K = 1, CUSTOMPTR
         L = FORMSEQ(K)
         WRITE(22) HLDRC2(L)          
  420 CONTINUE
      GO TO 700
C *****************************************************************************
C *                     CODE FOR DATAEASE 4.0
C *****************************************************************************
  500 CONTINUE
C
C   OPEN THE OLD AND NEW RDRRAAAA.DBM FILES
C
      OPEN (71,FILE='Q:RDRRAAAA.OLD',STATUS='OLD',FORM='BINARY'
     +     ,IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         CALL BADMSG(1,IOCHK)
         STOP 3
      ENDIF   
      OPEN (22,FILE='Q:RDRRAAAA.DBM',STATUS='NEW',FORM='BINARY'
     +     ,IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         CALL BADMSG(2,IOCHK)
         STOP 4
      ENDIF        
C
C     READ ALL THE ENTRIES FROM THE RDR FILE INTO THE HOLDING ARRAY
C
      DO 510 I = 1,500
         READ(71,ERR=715,END=520) HLDRC4(I)
  510 CONTINUE
      GO TO 725
  520 NUMFORMS = I - 1
C
C     SORT THE DATAEASE FORMS BY BUILDING AN ARRAY OF RECORD NUMBERS IN THE 
C     ORDER WANTED. START AT FORM #9 (1ST 8 ARE SYSTEM FORMS, DO NOT MOVE)
C     AND SEE IF THE FORM MATCHES ONE OF THE CLICOM FORM NAMES.  PUT THAT
C     RECORD NUMBER IN THE NEXT SLOT OF THE POINTER ARRAY, FORMSEQ. IF THE
C     FORM DOES NOT MATCH A CLICOM FORM, IT IS A USER-DEFINED FORM AND IS
C     PUT IN THE 1ST AVAILABLE SLOT AFTER THE CLICOM FORMS.
C
      DO 590 L = 9,NUMFORMS
         INREC4 = HLDRC4(L)
C---     RECORD TYPE 13,15 ARE DELETED ENTRIES IN RDRRAAAA. PUT AT END OF FORMS
         IF (HEADR4.EQ.13 .OR. HEADR4.EQ.15) GOTO 580
         DO 540 J = 1,20
            IF (INFRM4(J:J).EQ.NULL) THEN
                INFRM4(J:J) = ' '
            ENDIF
  540    CONTINUE               
         DO 570 K = 1,37
            IF (INFRM4 .EQ. DEFORM(K)) THEN         
               FORMSEQ(K) = L
               GO TO 590
            ENDIF
  570    CONTINUE
  580    CUSTOMPTR = CUSTOMPTR + 1
         FORMSEQ(CUSTOMPTR) = L
  590 CONTINUE
C              
C   WRITE OUT THE RDRRAAAA ENTRIES IN THE NEW ORDER
C
  600 CONTINUE
      DO 610 I = 1,8
         WRITE(22) HLDRC4(I)          
  610 CONTINUE
      DO 620 K = 1, CUSTOMPTR
         L = FORMSEQ(K)
         WRITE(22) HLDRC4(L)          
  620 CONTINUE
C------  NORMAL EXIT ----------
  700 CLOSE (22)
      CLOSE (71)
      STOP ' '
C
C   STOP CODE IF A READ ERROR ON THE RDRRAAAA.DBM FILE
C
  715 CLOSE (22)
      CLOSE (71)
      STOP 2
C
C   STOP CODE IF TOO MANY RECORDS IN THE RDRRAAAA.DBM FILE
C
  725 CLOSE (22)
      CLOSE (71)
      STOP 1
      END
C**********************************************************************
      SUBROUTINE BADMSG (NFILE,IOCHK)
C----------------------------------------------------------------------
C     ROUTINE TO PRINT AN ERROR MESSAGE LIKE OPENMSG WITHOUT THE
C     ABORT/RETRY QUESTION.
C     
C     INPUT ARGUMENT:
C
C     NFILE  INT2  FILE THAT COULD NOT BE OPENED. 
C                  1=Q:RDRRAAAA.OLD,   2=Q:RDRRAAAA.DBM
C     IOCHK  INT2  I/O ERROR NUMBER RETURNED FROM THE OPEN STATEMENT
C----------------------------------------------------------------------
      CHARACTER*2  INCHAR
      CHARACTER*78 MSGLIN
C
C---- DISPLAY ERROR MSG #43
C
      CALL GETMSG(43,MSGLIN)
      CALL LOCATE(10,1,IERR)
      CALL WRTSTR(MSGLIN,78,12,0)
      IF (NFILE .EQ. 1) THEN
         MSGLIN = 'Q:RDRRAAAA.OLD, SORTRDR, '
      ELSE
         MSGLIN = 'Q:RDRRAAAA.DBM, SORTRDR, '
      ENDIF
      WRITE(UNIT=MSGLIN(25:28),FMT='(I4)') IOCHK
      CALL LOCATE(11,1,IERR)
      CALL WRTSTR(MSGLIN,78,12,0)
      CALL BEEP
      CALL LOCATE(12,1,IERR)
C
C---- DISPLAY 'PRESS ANY KEY TO CONTINUE' AND WAIT.  GETMSG WRITES 2 OF 
C     THIS MSG
C
      CALL GETMSG(202,MSGLIN)
      CALL WRTSTR(MSGLIN,78,15,0)
      CALL LOCATE(13,1,IERR)
      CALL GETCHAR(1,INCHAR)
      CALL LOCATE(14,1,IERR)
      CALL CLRMSG(13)
      RETURN
      END
      