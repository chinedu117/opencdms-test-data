$STORAGE:2 
C     PROGRAM NODUPMRG
C
C   PROGRAM TO DO A NO-DUPE-MERGE OF NEW DATA TO EXISTING CLICOM CLIMATE
C       DATA FILES.  IT MERGES INPUT FILE 65 TO EXISTING FILE 25 PRODUCING 
C       OUTPUT FILE "MERGED.DAT" (UNIT 66).  IT WORKS WITH ALL CLIMATE
C       DATA TYPES AS WELL AS DAILY AND 10 DAY EXTREMES.
C       BOTH INPUT FILES MUST BE IN SORT BEFORE PASSED TO THIS PROGRAM.
C       THIS PROGRAM HAS BEEN MODIFIED TO WORK WITH EITHER DATAEASE VERSION 2.5
C       OR DATAEASE VERSION 4.0.
C
      INTERFACE TO SUBROUTINE CMDLIN(ADDRES,LENGTH,RESULT)
      INTEGER*4 ADDRES[VALUE],LENGTH[VALUE]
      CHARACTER*1 RESULT
      END
C
      PROGRAM NODUPMRG
C
C  FILE MANIPULATION VARIABLES
C    
      CHARACTER*500 INID1, INID2
      CHARACTER*1 INREC1(530), INREC2(530)
C
      CHARACTER*23 WRTID
      CHARACTER*48 MSGTXT
      CHARACTER*22 INFIL1,INFIL2,ERRFILE
      CHARACTER*24 FRMNAM(10)
      CHARACTER*8  BATFILE
C
C   CONTROL VARIABLES
C
      CHARACTER*64 RESULT
      CHARACTER*22 ID1, ID2, PRVID1, PRVID2
      CHARACTER*3 RECTYPE
      CHARACTER*1 MISSING1,MISSING2
      INTEGER*2 IDSTRT(10),IDLENGTH(10),RECLEN(10)
      INTEGER*4 PSP,PSPNCHR,OFFSET,IN1COUNT,IN2COUNT,OUTCOUNT,IDUPE
     +          ,NUMREC
      LOGICAL ERROR, FILE1, FILE2
C
      EQUIVALENCE (INID1,INREC1),(INID2,INREC2)
C
      DATA IDSTRT /10,16,15,9,13,31,9,5,5,11/
C     +    ,IDLENGTH /15,15,17,19,19,19,21,15,15,21/
     +    ,IDLENGTH /15,15,17,19,19,19, 0,15,15, 0/
C     +    ,RECLEN /84,210,186,67,151,529,62,51,51,164/
     +    ,RECLEN /84,210,186,67,151,529,62,51,51,165/
      DATA FRMNAM /'MONTHLY DATA','TEN DAY DATA','DAILY DATA'
     +   ,'SYNOPTIC DATA','HOURLY DATA','FIFTEEN MINUTE DATA'
     +   ,'UPPER-AIR DATA','Daily Means/Extremes'
     +   ,'Means/Extremes (10D)','NORMALS'/
      DATA INFIL2 /'Q:CLIMDATA.DAT'/
      DATA ERROR,FILE1,FILE2 /.FALSE.,.FALSE.,.FALSE./
      MISSING1 = CHAR(13)
      MISSING2 = CHAR(15)
C
C   LOCATE SEGMENTED ADDRESS OF THE BEGINNING OF THIS PROGRAM
C
      OFFSET = #00100000
      PSP = LOCFAR(NODUPMRG)
C
C   COMPUTE THE BEGINNING OF THE PROGRAM SEGMENT PREFIX (PSP)
C
      PSP = (PSP - MOD(PSP,#10000)) - OFFSET 
C
C   LOCATE POSITION OF COMMAND PARAMTERS WITHIN THE PSP
C
      PSPNCHR = PSP + #80
      PSP = PSP + #81
C
C   PASS THE ADDRESS OF THE COMMAND PARAMTERS TO CMDLIN WHICH DECODES
C      THE COMMAND AND RETURNS IT AS RESULT.
C
      CALL CMDLIN(PSP,PSPNCHR,RESULT)
C
C   PULL THE COMMAND (REC-TYPE AND FILE NAME) OUT OF THE RESULT
C
      RECTYPE = RESULT(1:3)
      DO 10 I=4,57
         IF (RESULT(I:I) .NE. ' ') THEN
            BATFILE = RESULT(I:I+7)
            GO TO 15
         ENDIF
10    CONTINUE
      CALL WRTMSG(3,299,12,0,0,'NODUPMRG',8)
      CALL WRTMSG(2,298,12,0,1,'NODUPMRG MLY MONTAAAA)',22)
      STOP 2
C
15    CALL SETMOD(3,IERR)
      CALL CLTEXT(0,0,IER)
C
C   READ THE CONTROL DATA TYPE FROM THE COMMAND LINE
C
      IF (RECTYPE.EQ.'MLY'.OR.RECTYPE.EQ.'mly') THEN
         ITYPE = 1
      ELSE IF (RECTYPE.EQ.'10D'.OR.RECTYPE.EQ.'10d') THEN
         ITYPE = 2
      ELSE IF (RECTYPE.EQ.'DLY'.OR.RECTYPE.EQ.'dly') THEN
         ITYPE = 3
      ELSE IF (RECTYPE.EQ.'SYN'.OR.RECTYPE.EQ.'syn') THEN
         ITYPE = 4
      ELSE IF (RECTYPE.EQ.'HLY'.OR.RECTYPE.EQ.'hly') THEN
         ITYPE = 5
      ELSE IF (RECTYPE.EQ.'15M'.OR.RECTYPE.EQ.'15m') THEN
         ITYPE = 6
      ELSE IF (RECTYPE.EQ.'U-A'.OR.RECTYPE.EQ.'u-a') THEN
         ITYPE = 7
      ELSE IF (RECTYPE.EQ.'DLX'.OR.RECTYPE.EQ.'dlx') THEN
         ITYPE = 8
      ELSE IF (RECTYPE.EQ.'10X'.OR.RECTYPE.EQ.'10x') THEN
         ITYPE = 9
      ELSE IF (RECTYPE.EQ.'NML'.OR.RECTYPE.EQ.'nml') THEN
         ITYPE = 10
      ELSE
         CALL WRTMSG(3,299,12,0,0,'NODUPMRG',8)
         CALL WRTMSG(2,298,12,0,1,'NODUPMRG MLY MONTAAAA)',22)
         STOP 2
       END IF   
C
C   SET THE BEGINNING AND END OF THE ID FIELDS IN THE DATA RECORDS
C
      IF (ITYPE.NE.7.AND.ITYPE.NE.10) THEN  
C
C          .. MONTHLY, 10 DAY, DAILY, SYNOPTIC, HOURLY, 15 MINUTE,
C             DAILY MEANS/EXTREMES, MEANS/EXTREMES (10D)
C             STATION ID
         IDBEG1 = IDSTRT(ITYPE)
         IDEND1 = IDBEG1 + 7
C          .. DATE -- YYYYMMDD -- DETAIL DEPENDS ON DATA TYPE
         DATLEN = IDLENGTH(ITYPE) - 11
         IDBEG2 = IDSTRT(ITYPE) + 11
         IDEND2 = IDBEG2 + DATLEN - 1
C          .. ELEMENT CODE        
         IDBEG3 = IDEND1 + 1 
         IDEND3 = IDBEG3 + 2
      ELSE IF (ITYPE.EQ.7) THEN
C          .. UPPER-AIR DATA
C             STATION ID      
         IDBEG1 = IDSTRT(ITYPE)
         IDEND1 = IDBEG1 + 7
C          .. DATE -- YYYYMMDDHH        
         IDBEG2 = IDEND1 + 1
         IDEND2 = IDBEG2 + 9
C          .. 
         IDBEG3 = IDBEG1 + 21
         IDEND3 = IDBEG3 + 2
      ELSE
C          .. NORMALS
C             STATION ID      
         IDBEG1 = IDSTRT(ITYPE)
         IDEND1 = IDBEG1 + 7
C          .. DATE -- YYYYYYYYMM
         IDBEG2 = IDEND1 + 1
C         IDEND2 = IDBEG2 + 8
         IDEND2 = IDBEG2 + 9
C          .. ELEMENT CODE         
         IDBEG3 = IDEND2 + 1
         IDEND3 = IDBEG3 + 2     
      END IF
      LENREC = RECLEN(ITYPE)
C
      ID1 = '      '
      ID2 = '      '
      PRVID1 = ' '
      PRVID2 = ' '
      WRTID(23:23) = CHAR(0)
C
C   FIND THE FILE NAME OF THE DATAEASE DATA FORM WANTED AND OPEN IT
C
      CALL FNDFIL(FRMNAM(ITYPE),INFIL1,NUMREC)
      IF (INFIL1.EQ.'       ') THEN
         STOP 2
      END IF
      IF (BATFILE .NE. INFIL1(3:10)) THEN
         INFIL2 = BATFILE // ' ' // INFIL1(3:10)
         CALL WRTMSG(3,187,12,0,1,INFIL2,17)
         STOP 3
      ENDIF
20    CONTINUE
      OPEN (25,FILE=INFIL1,STATUS='OLD',FORM='BINARY',SHARE='DENYWR'
     +       ,MODE='READ',IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(INFIL1,'NODUPMRG    ',IOCHK)
         GO TO 20 
      END IF
C
C   OPEN THE SECOND INPUT FILE
C
40    CONTINUE
      OPEN (65,FILE=INFIL2,STATUS='OLD',FORM='BINARY',SHARE='DENYWR'
     +       ,MODE='READ',IOSTAT=IOCHK)
      IF (IOCHK.NE.0) THEN
         CALL OPENMSG(INFIL2,'NODUPMRG    ',IOCHK)
         GO TO 40 
      END IF
C
C   OPEN THE OUTPUT FILE
C
      OPEN (66,FILE='Q:MERGED.DAT',STATUS='UNKNOWN',FORM='BINARY')
C
      IN1COUNT = 0
      IN2COUNT = 0
      OUTCOUNT = 0
      CALL LOCATE(14,0,IERR)
      CALL WRTSTR('Merging...',10,12,0)
      CALL LOCATE(16,0,IERR)
      CALL WRTSTR('File-1 -                         File-2 - ',42,14,0)
C -------------------------------------------------------------------
C   BEGIN MAIN LOOP
C -------------------------------------------------------------------
C
90    CONTINUE
      READ(25,END=210) (INREC1(I),I=1,LENREC)
      IF (INREC1(1).EQ.MISSING1 .OR. INREC1(1).EQ.MISSING2) THEN
         GO TO 90
      END IF      
      IN1COUNT = IN1COUNT + INT4(1)
      READ(65,END=380) (INREC2(I),I=1,LENREC)
      IN2COUNT = IN2COUNT + INT4(1)
      GO TO 105
C
C  READ A RECORD FROM BOTH INPUT FILES
C
100   CONTINUE
         READ(25,END=210) (INREC1(I),I=1,LENREC)
         IF (INREC1(1).EQ.MISSING1 .OR. INREC1(1).EQ.MISSING2) THEN
            GO TO 100
         END IF      
         IN1COUNT = IN1COUNT + INT4(1)
         READ(65,END=300) (INREC2(I),I=1,LENREC)
         IN2COUNT = IN2COUNT + INT4(1)
C 
C   SET RECORD IDs - REMEMBER INIDs ARE EQUIVALENCED TO INRECs
C
105      CONTINUE
         ID1 = INID1(IDBEG1:IDEND1)
         ID1(9:18) = INID1(IDBEG2:IDEND2)
         ID1(19:22) = INID1(IDBEG3:IDEND3)
         IF (ID1.LT.PRVID1) THEN
            FILE1 = .TRUE.
            ERRFILE = INFIL1
            GO TO 500
         ELSE IF (ID1.EQ.PRVID1) THEN
            FILE1 = .TRUE.
            ERRFILE = INFIL1
            GO TO 510
         END IF
         ID2 = INID2(IDBEG1:IDEND1)
         ID2(9:18) = INID2(IDBEG2:IDEND2)
         ID2(19:22) = INID2(IDBEG3:IDEND3)
         IF (ID2.LT.PRVID2) THEN
            FILE2 = .TRUE.
            ERRFILE = INFIL2
            GO TO 500
         ELSE IF (ID2.EQ.PRVID2) THEN
            FILE2 = .TRUE.
            ERRFILE = INFIL2
            GO TO 510
         END IF
         PRVID1 = ID1
         PRVID2 = ID2
         CALL LOCATE(16,9,IERR)
         WRTID(1:22) = ID1(1:22)
         CALL CWRITE(WRTID,12,IERR)
         CALL LOCATE(16,42,IERR)
         WRTID(1:22) = ID2(1:22)
         CALL CWRITE(WRTID,12,IERR)
C
C   CURRENT RECORD READ FROM INPUT FILE-1 IS PAST CURRENT RECORD
C   FROM INPUT FILE-2.  WRITE THE RECORD FROM FILE-2 AND READ ANOTHER
C
120      CONTINUE
         IF (ID1.GT.ID2) THEN
            WRITE(66) (INREC2(I),I=1,LENREC)
            OUTCOUNT = OUTCOUNT + INT4(1)
            READ(65,END=300) (INREC2(I),I=1,LENREC)
            IN2COUNT = IN2COUNT + INT4(1)
            ID2 = INID2(IDBEG1:IDEND1)
            ID2(9:18) = INID2(IDBEG2:IDEND2)
            ID2(19:22) = INID2(IDBEG3:IDEND3)
            IF (ID2.LT.PRVID2) THEN
               FILE2 = .TRUE.
               ERRFILE = INFIL2
               GO TO 500
            ELSE IF (ID2.EQ.PRVID2) THEN
               FILE2 = .TRUE.
               ERRFILE = INFIL2
               GO TO 510
            END IF
            PRVID2 = ID2
            CALL LOCATE(16,42,IERR)
            WRTID(1:22) = ID2(1:22)
            CALL CWRITE(WRTID,12,IERR)
             GO TO 120
C
C   CURRENT RECORD READ FROM INPUT FILE-2 IS PAST CURRENT RECORD
C   FROM INPUT FILE-1.  WRITE THE RECORD FROM FILE-1 AND READ ANOTHER
C
         ELSE IF (ID1.LT.ID2) THEN
            WRITE(66) (INREC1(I),I=1,LENREC)
            OUTCOUNT = OUTCOUNT + INT4(1)
150         CONTINUE
            READ(25,END=200) (INREC1(I),I=1,LENREC)
            IF (INREC1(1).EQ.MISSING1 .OR. INREC1(1).EQ.MISSING2) THEN
               GO TO 150
            END IF      
            IN1COUNT = IN1COUNT + INT4(1)
            ID1 = INID1(IDBEG1:IDEND1)
            ID1(9:18) = INID1(IDBEG2:IDEND2)
            ID1(19:22) = INID1(IDBEG3:IDEND3)
            IF (ID1.LT.PRVID1) THEN
               FILE1 = .TRUE.
               ERRFILE = INFIL1
               GO TO 500
            ELSE IF (ID1.EQ.PRVID1) THEN
               FILE1 = .TRUE.
               ERRFILE = INFIL1
               GO TO 510
            END IF
            PRVID1 = ID1
            CALL LOCATE(16,9,IERR)
            WRTID(1:22) = ID1(1:22)
            CALL CWRITE(WRTID,12,IERR)
             GO TO 120
C
C   CURRENT RECORDS READ FROM BOTH INPUT FILES HAVE DUPLICATE IDs.  
C   WRITE THE RECORD FROM FILE-2 AND GO TO 100 TO READ ANOTHER FROM EACH
C
         ELSE 
            WRITE(66) (INREC2(I),I=1,LENREC)
            OUTCOUNT = OUTCOUNT + INT4(1)
            GO TO 100
         END IF
C
C   REACH THIS POINT IF HAVE READ END OF FILE ON INPUT FILE 25
C   COPY REST OF INPUT FILE 65
C
200   CONTINUE
         WRITE(66) (INREC2(I),I=1,LENREC)
         OUTCOUNT = OUTCOUNT + INT4(1)
210      CONTINUE
         READ(65,END=400) (INREC2(I),I=1,LENREC)
         IN2COUNT = IN2COUNT + INT4(1)
         ID2 = INID2(IDBEG1:IDEND1)
         ID2(9:18) = INID2(IDBEG2:IDEND2)
         ID2(19:22) = INID2(IDBEG3:IDEND3)
         IF (ID2.LT.PRVID2) THEN
            FILE2 = .TRUE.
            ERRFILE = INFIL2
            GO TO 500
         ELSE IF (ID2.EQ.PRVID2) THEN
            FILE2 = .TRUE.
            ERRFILE = INFIL2
            GO TO 510
         END IF
         PRVID2 = ID2
         CALL LOCATE(16,42,IERR)
         WRTID(1:22) = ID2(1:22)
         CALL CWRITE(WRTID,12,IERR)
          GO TO 200
C
C   REACH THIS POINT IF HAVE READ END OF FILE ON INPUT FILE 65
C   COPY REST OF INPUT FILE 25
C
300   CONTINUE
         WRITE(66) (INREC1(I),I=1,LENREC)
         OUTCOUNT = OUTCOUNT + INT4(1)
320      CONTINUE
         READ(25,END=400) (INREC1(I),I=1,LENREC)
         IF (INREC1(1).EQ.MISSING1 .OR. INREC1(1).EQ.MISSING2) THEN
            GO TO 320
         END IF      
         IN1COUNT = IN1COUNT + INT4(1)
         ID1 = INID1(IDBEG1:IDEND1)
         ID1(9:18) = INID1(IDBEG2:IDEND2)
         ID1(19:22) = INID1(IDBEG3:IDEND3)
         IF (ID1.LT.PRVID1) THEN
            FILE1 = .TRUE.
            ERRFILE = INFIL1
            GO TO 500
         ELSE IF (ID1.EQ.PRVID1) THEN
            FILE1 = .TRUE.
            ERRFILE = INFIL1
            GO TO 510
         END IF
         PRVID1 = ID1
         CALL LOCATE(16,9,IERR)
         WRTID(1:22) = ID1(1:22)
         CALL CWRITE(WRTID,12,IERR)
         GO TO 300
C
C   REACH THIS POINT IF INPUT FILE-2 IS EMPTY
C
380   CONTINUE
      CALL WRTMSG(5,363,12,0,0,INFIL2,22)
      CALL WRTMSG(4,364,12,1,1,INFIL1,22)
      ERROR = .TRUE.
C
C   REACH THIS POINT WHEN EOF READ ON BOTH INPUT FILES - CLOSE FILES
C   
400   CONTINUE
      CLOSE(25)
      CLOSE(65)
      CLOSE(66)
C
C  WRITE SUMMARY AND SET NUMBER OF RECORDS IN NEW OUTPUT FILE IN THE 
C  DATAEASE RDRRAAAA.DBM FILE.  
C
      CALL LOCATE(23,0,IERR)
      IF (ERROR) THEN
         STOP 2
      ELSE
         IDUPE = IN1COUNT + IN2COUNT - OUTCOUNT
         WRITE(*,'(I6,A20)') IDUPE,' records replaced   '
         WRITE(*,'(I6,A20)') IN2COUNT - IDUPE,' records added      '
         WRITE(*,'(I6,A36)') 
     +        OUTCOUNT,' total records now in output file   '
         WRITE(*,*) ' '
         CALL RDRSET(RECTYPE,OUTCOUNT)
         STOP ' '
      END IF
C
C  REACH THIS POINT IF ONE OF THE INPUT FILES IS OUT OF SORT
C
  500 CONTINUE
      NMSG = 178
      GO TO 599
C
C  REACH THIS POINT IF ONE OF THE INPUT FILES HAS DUPLICATE RECORDS
C      
  510 CONTINUE
      NMSG = 419
C      
  599 CONTINUE      
      LGTH = LNG(ERRFILE)
      IF (FILE1) THEN
         MSGTXT = ERRFILE(1:LGTH) // ' (File-1)'
      ELSE IF (FILE2) THEN
         MSGTXT = ERRFILE(1:LGTH) // ' (File-2)'
      END IF
      LGTH=LNG(MSGTXT)
      CALL WRTMSG(5,NMSG,12,0,0,MSGTXT,LGTH)
      CALL WRTMSG(3,365,12,1,1,' ',0)
      CALL LOCATE(23,0,IERR)
      STOP 2      
      END

$PAGE
************************************************************************
      SUBROUTINE RDRSET(RECTYPE,ICOUNT)
C
C   ROUTINE TO SET THE NUMBER OF RECORDS INDICATED IN THE RECTYPE RECORD
C   OF THE DATAEASE FILE DIRECTORY (RDRRAAAA.DBM)
C
      CHARACTER*3 RECTYPE,DEVER
      INTEGER*2 RECNUM
      INTEGER*4 ICOUNT
      LOGICAL FOUND
C
      CHARACTER*2 INNUM2,INDEL2
      CHARACTER*1 INREC(51)
      EQUIVALENCE (INNUM2,INREC(30)),(INDEL2,INREC(32))
C
      CHARACTER*4 INNUM4,INDEL4
      CHARACTER*1 INREC4(55)
      EQUIVALENCE (INNUM4,INREC4(30)),(INDEL4,INREC4(34))

      CHARACTER*4 CHRDEL4,CNUM4
      INTEGER*4 NUMDEL4,NUM4
      EQUIVALENCE (CHRDEL4,NUMDEL4),(CNUM4,NUM4)
C
      NULL = CHAR(0)
      NUMDEL4 = 0
C 
C    DETERMINE WHICH VERSION OF DATAEASE IS IN USE
C
      CALL GETDEASE(DEVER)
      IF (DEVER.EQ.'4.0') THEN
         GOTO 500
      END IF
C *****************************************************************************
C *                     CODE FOR DATAEASE 2.5
C *****************************************************************************
C
C   UPDATE THE RDRRAAAA ENTRY FOR THE RECTYPE SPECIFIED 
C
      CALL RDRREC(RECTYPE,RECNUM)
      IF (RECNUM.EQ.0) THEN
         STOP 2
      ELSE
         READ(22,REC=RECNUM) INREC
         FOUND = .TRUE.
         NUM4 = ICOUNT
C    --- CNUM4 NOW EQUALS ICOUNT BECAUSE OF EQUIVALENCE TO NUM4
C        CONVERT VALUE TO INT*2 AND WRITE INTO OUTPUT RECORD
         INNUM2 = CNUM4(1:2)
         INDEL2 = CHRDEL4(1:2)
         WRITE(22,REC=RECNUM) INREC
         CLOSE(22)
         GOTO 999
      END IF
C *****************************************************************************
C *                     CODE FOR DATAEASE 4.0
C *****************************************************************************
C
C   UPDATE THE RDRRAAAA ENTRY FOR THE RECTYPE SPECIFIED 
C
 500  CALL RDRREC(RECTYPE,RECNUM)
      IF (RECNUM.EQ.0) THEN
         STOP 2
      ELSE
         READ(22,REC=RECNUM) INREC4
         FOUND = .TRUE.
         NUM4 = ICOUNT
         INNUM4 = CNUM4
         INDEL4 = CHRDEL4
         WRITE(22,REC=RECNUM) INREC4
         CLOSE(22)
      END IF
    
 999  RETURN
      END
  