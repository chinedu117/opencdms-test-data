$storage:2
      SUBROUTINE DSPWIN(FILNAME)
C
C  THIS ROUTINE PRINTS A TEXT FILE IN A SCREEN WINDOW WITH A PAUSE AT THE
C     END OF EACH PAGE.  IT RETURNS IF AN F4 KEY IS HIT, SCROLLS UP IF A
C     PgUp IS HIT AND GOES TO THE NEXT PAGE IF A PgDn IS HIT.
C     CHARACTERS WITHIN THE MESSAGE FILE DELIMITTED BY ^ CHARACTERS ARE
C     WRITTEN WITH A RED BACKGROUND (THESE ^ MESSAGES CAN NOT SPAN LINES.
C     EACH LINE MUST HAVE ITS OWN SET OF ^'S)
C
c     ---> MAXIMUM OF 60 CHARACTERS PER LINE AND 120 LINES PER FILE <---
C
      CHARACTER*60 TXTLINE(120)
      CHARACTER*64 FILNAME
      CHARACTER*2 INCHAR
      INTEGER*2 STRTROW,STRTCOL,ENDROW,ENDCOL,BUFFER(1300,2)
      COMMON /WINDOW/ BUFFER
C
      DATA IFG,IBG,IBG2 /0,3,4/
      DATA IWIN /2/
C
C   OPEN THE TEXT WINDOW WHERE IT IS LEAST OBTRUSIVE TO THE CURRENT
C   CURSOR POSITION
C
      CALL POSLIN(JROW,JCOL)
      IF (JCOL.LT.40) THEN
         STRTCOL = 80 - 64
      ELSE
         STRTCOL = 0
      END IF
      IF (JROW.LT.12) THEN
         STRTROW = 25 - 15
      ELSE
         STRTROW = 0
      END IF
      ENDCOL = STRTCOL + 63
      ENDROW = STRTROW + 14
      CALL OPENWIN(IWIN,BUFFER(1,IWIN),STRTROW,STRTCOL,ENDROW,ENDCOL)
C
C   LOAD THE FILE TO BE PRINTED INTO TXTLINE (MAX 120 LINES)
C
   40 CONTINUE
      OPEN(59,FILE=FILNAME,STATUS='OLD',FORM='FORMATTED'
     +      ,SHARE='DENYWR',MODE='READ',IOSTAT=IOCHK)
      IF(IOCHK.NE.0) THEN
         TXTLINE(1) = FILNAME
         IF (IOCHK.EQ.6416) THEN
            CALL WRTMSG(3,153,12,1,1,TXTLINE(1),20)
            CALL CLOSWIN(IWIN,BUFFER(1,IWIN))
            RETURN
         ELSE
            CALL OPENMSG(FILNAME,'DSPWIN      ',IOCHK)
            GO TO 40
         END IF
      END IF
      DO 70 I = 1,120
         READ(59,'(A60)',END=80) TXTLINE(I)
         NUMLINE = I
   70 CONTINUE
   80 CONTINUE
      CLOSE(59)
C
C   PRINT THE TEXT FILE ONE PAGE AT A TIME AND CHECK INPUT FROM THE USER
C
      IPAGE = 1
      CALL WINWRT(IPAGE,NUMLINE,TXTLINE,IFG,IBG,IBG2,STRTROW,STRTCOL
     +            ,IWIN)
  100 CONTINUE
      CALL GETCHAR(0,INCHAR)
      IF (INCHAR.EQ.'DP') THEN
         CALL WINWRT(IPAGE,NUMLINE,TXTLINE,IFG,IBG,IBG2,STRTROW,STRTCOL
     +              ,IWIN)
      ELSE IF (INCHAR.EQ.'UP') THEN
         IF (IPAGE.GT.2) THEN
            IPAGE = IPAGE - 2
            CALL WINWRT(IPAGE,NUMLINE,TXTLINE,IFG,IBG,IBG2,STRTROW
     +          ,STRTCOL,IWIN)
         ELSE
            CALL BEEP
         END IF
      ELSE IF (INCHAR.EQ.'HO') THEN
         IPAGE = 1
         CALL WINWRT(IPAGE,NUMLINE,TXTLINE,IFG,IBG,IBG2,STRTROW,STRTCOL
     +              ,IWIN)
      ELSE IF (INCHAR.EQ.'4F') THEN
         CALL LOCATE(24,0,IERR)
         CALL CLOSWIN(IWIN,BUFFER(1,IWIN))
         RETURN
      END IF
      GO TO 100  
      END
C
$PAGE
***********************************************************************

      SUBROUTINE WINWRT(IPAGE,NUMLINE,TXTLINE,IFG,IBG,IBG2,STRTROW
     +                 ,STRTCOL,IWIN)
C
C   ROUTINE TO WRITE A WINDOW WORTH OF TXTLIN TO THE SCREEN
C   AND MOVE PAGE POINTER TO NEXT PAGE
C
      CHARACTER*60 TXTLINE(120),MORTXT,ENDTXT
      CHARACTER*81 MESSAGE
      CHARACTER*3 DEVERS
      INTEGER*2 STRTROW,STRTCOL,LENMSG
      LOGICAL FRSTCL
      DATA FRSTCL /.TRUE./ ,MESSAGE,MORTXT,ENDTXT /3*' '/
C
C   ON FIRST CALL READ ALL MESSAGE TEXT
C
      IF (FRSTCL) THEN
         FRSTCL = .FALSE.
         CALL GETDEASE(DEVERS)
         CALL GETMSG(310,MESSAGE)
         DO 50 J = 1,80
            IF (MESSAGE(J:J).EQ.',') THEN
               ISPLIT = J
               GO TO 55
            END IF
50       CONTINUE
55       CONTINUE
         MORTXT = '^ '
         MORTXT(2:ISPLIT-2) = MESSAGE(2:ISPLIT-2)
         MORTXT(ISPLIT-1:ISPLIT-1) = '^' 
         ENDTXT = '^  '
         DO 60 J = ISPLIT+2,80
            IF (MESSAGE(J:J).EQ.'''') THEN
               GO TO 65
            END IF
            J1 = J - ISPLIT  
            ENDTXT(J1:J1) = MESSAGE(J:J)
60       CONTINUE
65       CONTINUE
         J1 = J1 + 1
         ENDTXT (J1:J1) = '^'
         IF (DEVERS.EQ.'4.0') THEN
            NMSG=495
         ELSE
            NMSG=494
         ENDIF      
         CALL GETMSG(NMSG,MESSAGE)
         CALL GETMSG(999,MESSAGE)
         DO 70 J = 80,1,-1
            IF (MESSAGE(J:J).NE.' ') THEN
               GO TO 75
            END IF
70       CONTINUE
75       CONTINUE
         LENMSG = J + 1
      END IF
C
C  SET POINTER TO CURRENT LINE NUMBER IN THE TEXT ARRAY
C
      ISTRT = (IPAGE - 1) * 12 + 1
      IEND = ISTRT + 11
      IF (ISTRT.GT.NUMLINE) THEN
         CALL BEEP
         RETURN
      ELSE IF (IEND.GT.NUMLINE) THEN
         IEND = NUMLINE
      END IF
      IPAGE = IPAGE + 1
C
C  DISPLAY THE CURRENT PAGE 
C
      I1 = 0
      CALL CLRWIN(IWIN)
      DO 200 I = ISTRT,IEND
         I1 = I1 + 1
         IROW = STRTROW + I1 
         CALL LOCATE(IROW,STRTCOL+2,IERR)
         CALL DSPSTR(TXTLINE(I),60,IFG,IBG,IBG2)
200   CONTINUE
C
C  TELL USER IF THERE IS MORE OR THIS IS THE END OF THE TEXT
C
      IF (IEND.EQ.NUMLINE) THEN
         IROW = IROW + 1
         CALL LOCATE(IROW,STRTCOL+2,IERR)
         CALL DSPSTR(ENDTXT,60,IFG,IBG,IBG2)
      ELSE
         CALL LOCATE(STRTROW+13,STRTCOL+2,IERR)
         CALL DSPSTR(MORTXT,60,IFG,IBG,IBG2)
      END IF
      CALL LOCATE(STRTROW+14,STRTCOL+2,IERR)
      CALL DSPSTR(MESSAGE,LENMSG,IFG,IBG,IBG2)
      RETURN
      END 
************************************************************************
      SUBROUTINE DSPSTR(FIELD,FLDLEN,FGCOLOR,BGCOLOR,BG2COLOR)
C
C  ROUTINE TO WRITE A STRING WITH THE GIVEN FORGROUND AND BACKGROUND.
C  TEXT BETWEEN ^'S IS WRITTEN WITH THE SECOND BACKGROUND COLOR.
C
      INTEGER*2 FLDLEN,FGCOLOR,BGCOLOR,BG2COLOR
      CHARACTER*1 FIELD(FLDLEN)
C
      IBG = BGCOLOR
      ISKP = 0
      CALL POSLIN(JROW,JCOL)
      DO 100 I1 = 1,FLDLEN
         IF (FIELD(I1).EQ.'^') THEN
            IF (IBG.EQ.BGCOLOR) THEN
               IBG = BG2COLOR
            ELSE 
               IBG = BGCOLOR
            END IF
            ISKP = ISKP + 1
         ELSE
            CALL CHRWRT(FIELD(I1),IBG,FGCOLOR,1)
         END IF
         IF (JCOL+I1.LE.79) THEN
            CALL LOCATE(JROW,JCOL+I1-ISKP,IERR)      
         END IF
100   CONTINUE
C
C  IF THIS LINE CONTAINED ^ CHARACTERS THEN THEY WERE SKIPPED SO THE 
C  OUTPUT LINE WAS SHORT.  FILL WITH REST OF THE LINE WITH SPACES.
C
      IF (ISKP.GT.0) THEN
         DO 120 I1=1,ISKP
            CALL CHRWRT(' ',IBG,FGCOLOR,1)
            IF (JCOL+I1.LE.79) THEN
               CALL LOCATE(JROW,JCOL+I1-ISKP,IERR)      
            END IF
120      CONTINUE
      END IF
      RETURN
      END
