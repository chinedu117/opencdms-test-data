$STORAGE:2
      SUBROUTINE VALWIN(IUNIT,RTNVAL,RECLEN,VALTYP,ITYPE)
C
C   ROUTINE TO DISPLAY THE RELEVANT INFORMATION FROM THE FORTRAN DIRECT
C   FILE CURRENTLY OPEN AS FILE IUNIT AND ALLOW THE USER TO SELECT
C   VALUES FROM THE RECORDS SHOWN.  FOR VALUE TYPES 3 AND 7, USER CAN
C   REQUEST THAT THE RECORD SELECTED BE DELETED BY PRESSING F7.
C
C   INPUT:
C      IUNIT....UNIT NUMBER OF THE FILE TO BE READ
C      RECLEN...RECORD LENGTH OF THE INPUT FILE (# OF CHARACTERS)
C      VALTYP...TYPE OF DATA VALUE BEING RETRIEVED 
C               1 = STNID
C               2 = ELEMENT CODE
C               3 = FILENAME AND 32 CHAR DESCRIPTION
C               4 = MENU NAME
C               5 = UNDEFINED (DDSID in SETUP and UNLDATA UNDER CONSIDERATION)
C               6 = FILENAME AND 32 CHAR DESCRIPTION -- MAP STATION LIST
C               7 = FILENAME AND 32 CHAR DESCRIPTION + PALETTE -- GRAPHICS
C                   SCREEN
C      ITYPE....IF VALTYP = 2 THEN ITYPE = OBS-TYPE INTEGER CODE (1-7)
C   OUTPUT:
C      RTNVAL...CONTENTS OF THE RECORD SELECTED.  IT IS SET TO SPACES
C               IF NO RECORD IS SELECTED.  (CHAR*RECLEN)
C      ITYPE....IF VALTYP = 3 THEN ITYPE = 1 ON EXIT IF F7-DELETE
C                   HAS BEEN PRESSED
C               IF VALTYP = 6 THEN ITYPE = 1 ON EXIT IF F9-OPTIONS
C                   HAS BEEN PRESSED
C               IF VALTYP = 7 THEN ITYPE = 1 ON EXIT IF F7-DELETE
C                   HAS BEEN PRESSED
C
C      THE FOLLOWING VALUES ARE SET BY THIS ROUTINE TO CONFORM TO THE 
C      VALTYP SPECIFIED.
C
C      IDBEG....CHARACTER POSITION OF RTNVAL WHERE KEY TO BE USED
C               TO IDENTIFY UNIQUE RECORDS BEGINS
C      IDLEN....LENGTH OF ID KEY
C      SRTBEG...CHARACTER POSITION OF RTNVAL WHERE KEY TO BE USED
C               FOR THE SORT OF RECORDS DISPLAYED BEGINS
C      SRTLEN...LENGTH OF SORT KEY
C
      INTEGER*2 RECLEN,SRTBEG, SRTLEN,VALTYP,WINWIDTH,RTNLEN,
     +          LOWID,HIGHID,LOWELEM(8),HIELEM(8),BUFFER(1300,2)
      CHARACTER*1 SRCHKY,FCHAR,RTNVAL(RECLEN)
      CHARACTER*2 INCHAR,YESUP,NOUP,IDUM
      CHARACTER*3 DEVERS
      CHARACTER*64 HELPFILE
      CHARACTER*80 INID,PREVID,HLDREC(24),INREC,PREVREC
      CHARACTER*80 MSGLN1,MSGLN2,MSGLN3,MSGLN4,MSGLN5,MSGLN6,MSGLN7
      INTEGER*4 JREC(100)
      LOGICAL FOUND,FIRSTCALL
      COMMON /WINDOW/ BUFFER
      DATA LOWELEM,HIELEM /201,401,001,3*101,301,001
     +                    ,300,500,100,3*200,307,500/
      DATA FIRSTCALL /.TRUE./, HELPFILE /'P:\HELP\VALWIN.HLP'/
      DATA IWINDOW /1/
C
C   ON FIRST CALL TO THIS ROUTINE - READ MESSAGE TEXT
C
      IF (FIRSTCALL) THEN
         FIRSTCALL = .FALSE.
         CALL GETYN(1,2,YESUP,IDUM)
         CALL GETYN(2,2, NOUP,IDUM)
         CALL GETDEASE(DEVERS)
         CALL GETMSG(223,MSGLN1)
         CALL GETMSG(279,MSGLN2)
         CALL GETMSG(100,MSGLN3)
         IF (DEVERS.EQ.'4.0') THEN
            NMSG4=319
            NMSG5=321
            NMSG7=590
         ELSE
            NMSG4=318
            NMSG5=320
            NMSG7=589
         ENDIF
         CALL GETMSG(NMSG4,MSGLN4)
         CALL GETMSG(NMSG5,MSGLN5)
         CALL GETMSG(NMSG7,MSGLN7)
         CALL GETMSG(372,MSGLN6)
         CALL GETMSG(999,MSGLN6)
         MSGLEN = LNG(MSGLN1)
         MSG6LEN = LNG(MSGLN6)
      END IF    
C
C   SET THE SEARCH AND SORT POSITIONS TO MATCH THE VALTYP WANTED.
C   ALSO SET THE WINDOW WIDTH.
C
      IF (VALTYP.EQ.1) THEN
         IDBEG = 1
         IDLEN = 8
         SRTBEG = 17
         SRTLEN = 24
         WINWIDTH = 40
         J = 1
      ELSE IF (VALTYP.EQ.2) THEN
         JTYPE = ITYPE
         IF (ITYPE.LT.1.OR.ITYPE.GT.7) THEN
            JTYPE = 8
         END IF
         IDBEG = 1
         IDLEN = 3
         SRTBEG = 26
         SRTLEN = 42
         LOWID = LOWELEM(JTYPE)
         HIGHID = HIELEM(JTYPE)
         WINWIDTH = 50
         J = LOWID - 1
      ELSE IF (VALTYP.EQ.3 .OR. VALTYP.EQ.7) THEN
         IDBEG = 1
         IDLEN = 8
         SRTBEG = 10
         SRTLEN = 32
         WINWIDTH = 50
         J = 0
         ITYPE = 0
      ELSE IF (VALTYP.EQ.4) THEN
         IDBEG = 2
         IDLEN = 12
         SRTBEG = 14
         SRTLEN = 34
         WINWIDTH = 50
         J = 0
         ITYPE = 0
      ELSE IF (VALTYP.EQ.6) THEN
         IDBEG = 1
         IDLEN = 8
         SRTBEG = 10
         SRTLEN = 32
         WINWIDTH = 50
         J = 0
         ITYPE = 0
      ELSE
         RETURN
      END IF
      IWIDTH = IDLEN + SRTLEN + 1
C ---- RTNLEN IS THE LENGTH OF STRING TO COPY INTO HLDREC IN ADDITION TO INID
      IF (VALTYP .EQ. 7) THEN
         RTNLEN = 64
      ELSE
         RTNLEN = SRTLEN
      ENDIF
C
C     DETERMINE WHERE THE WINDOW SHOULD BE OPENED
C
      CALL POSLIN(JROW,JCOL)
      IF (JCOL.LT.40) THEN
         ISTRT = 80 - WINWIDTH
      ELSE
         ISTRT = 0
      END IF
C
C   OPEN AND CLEAR THE SCREEN WINDOW
C
      IEND = ISTRT + WINWIDTH - 1
      CALL OPENWIN(IWINDOW,BUFFER(1,IWINDOW),0,ISTRT,24,IEND)
C
C  INITIALIZE
C
      SRCHKY = ' '
      PREVID = '        '
      I1 = 1
      IPAGE = 0
      CALL LOCATE(22,ISTRT+1,IERR)
      CALL WRTSTR(MSGLN2,18,12,0)
C
C   READ ONE SCREEN OF INPUT RECORDS (22 ENTRIES)
C   IF THE SRCHKY IS SET, ONLY SELECT RECORDS WHOSE SORT KEY BEGIN WITH
C   IT. 
C
100   CONTINUE
      DO 105 I2 = 1,22
         HLDREC(I2) = ' '
105   CONTINUE
      I = 0
      IPAGE = IPAGE + 1
      JREC(IPAGE) = J + 1
110   CONTINUE
         FOUND = .TRUE.
         J = J + 1
         READ(IUNIT,REC=J,ERR=120) (INREC(I3:I3),I3=1,RECLEN)
         IF (VALTYP.EQ.2.AND.J.GT.HIGHID.AND.J.LT.500) THEN
            J = 499
            GO TO 110
         END IF
         IF (SRCHKY.NE.' ') THEN
            IF (VALTYP.EQ.4) THEN
               FCHAR = INREC(IDBEG:IDBEG) 
            ELSE
               FCHAR = INREC(SRTBEG:SRTBEG)
            END IF
            CALL UPPER(FCHAR,1)
            IF (FCHAR.NE.SRCHKY) THEN
               GO TO 110
            END IF
         END IF
         INID = INREC(IDBEG:IDBEG+IDLEN-1)
C
C    IF VALTYP = 1 THEN IGNORE MULTIPLE ENTRIES FOR THE ID 
C
         IF (VALTYP.EQ.1) THEN
            IF (INID.NE.PREVID) THEN
               IF (PREVID.NE.'      ') THEN
                  I = I + 1
                  HLDREC(I) = PREVREC
                  CALL NAMSRT(I,HLDREC,IDLEN+2,SRTLEN)
               END IF
            END IF
C
C    IF VALTYPE = 2  ONLY SELECT ELEMENTS THAT MATCH THE OBS-TYPE AND
C                    IGNORE UNDEFINED ELEMENT RECORDS
C
         ELSE IF (VALTYP.EQ.2) THEN
            READ(INID,'(I3)',ERR=110) KELEM
            IF (KELEM.NE.J) THEN
               GO TO 110
            ELSE IF (PREVID.NE.'   ') THEN
               I = I + 1
               HLDREC(I) = PREVREC
               CALL NAMSRT(I,HLDREC,IDLEN+2,SRTLEN)
            END IF               
C
C    IF VALTYP = 3,6,7 SKIP RECORDS MARKED AS DELETED
C
         ELSE IF (VALTYP.EQ.3 .OR. VALTYP.EQ.6 .OR. VALTYP.EQ.7) THEN
            IF (INID(1:8).EQ.'********') THEN            
               GO TO 110
            ELSE IF (PREVID.NE.'  ') THEN
               I = I + 1
               HLDREC(I) = PREVREC
               CALL NAMSRT(I,HLDREC,IDLEN+2,SRTLEN)
            END IF
C
C    IF VALTYP = 4 SKIP RECORDS MARKED AS DELETED AND USE ID AS SORT KEY
C
         ELSE IF (VALTYP.EQ.4) THEN
            IF (INREC(1:1).EQ.'*') THEN            
               GO TO 110
            ELSE IF (PREVID.NE.'  ') THEN
               I = I + 1
               HLDREC(I) = PREVREC
               CALL NAMSRT(I,HLDREC,1,IDLEN)
            END IF
         END IF
C
C  RTNLEN IS THE LENGTH OF STRING TO COPY INTO HLDREC IN ADDITION TO INID. SAME
C  AS SRTLEN EXCEPT WHEN VALTYP=7, HLDREC IS LONGER THAN DISPLAYED IN WINDOW
C
         PREVID = INID
         PREVREC = INID
         PREVREC(IDLEN+2:IDLEN+RTNLEN+1) = INREC(SRTBEG:SRTBEG+RTNLEN-1)
         IF (I.LT.22) THEN
            GO TO 110
         END IF
         GO TO 130
C
C   GET HERE IF READ END OF FILE IN INPUT FILE
C
120   CONTINUE
      I = I + 1
      IF (PREVID.EQ.'        ') THEN
         HLDREC(1) = '       '
         FOUND = .FALSE.
      ELSE
         HLDREC(I) = PREVREC
         CALL NAMSRT(I,HLDREC,IDLEN+2,SRTLEN)
      END IF
C
C   DISPLAY THE SCREEN OF DATA
C
130   CONTINUE
      IROW = 0
      ICOL = 0
      CALL CLRWIN(IWINDOW)
      IF (FOUND) THEN
         DO 150 I2 = 1,I
            CALL DSPREC(I2,ISTRT+1,0,HLDREC(I2),IWIDTH)
150      CONTINUE
      END IF
      CALL LOCATE(23,ISTRT+1,IERR)
      CALL WRTSTR(MSGLN1,MSGLEN,15,3)
      CALL WRTSTR(SRCHKY,1,15,1)
      IF (VALTYP.EQ.3 .OR. VALTYP.EQ.7) THEN
         CALL LOCATE(24,ISTRT+2,IERR)
         CALL WRTSTR(MSGLN4,45,0,3)
      ELSE IF (VALTYP.EQ.6) THEN
         CALL LOCATE(24,ISTRT+1,IERR)
         CALL WRTSTR(MSGLN7,48,0,3)
      ELSE   
         CALL LOCATE(24,ISTRT+2,IERR)
         CALL WRTSTR(MSGLN5,37,0,3)
      END IF
C
C   HIGHLIGHT THE CURRENT LINE AND READ THE USER INPUT
C
180   CONTINUE
      IF (FOUND) THEN
         CALL DSPREC(I1,ISTRT+1,1,HLDREC(I1),IWIDTH)
         CALL GETCHAR(0,INCHAR)
      ELSE
         CALL CLRWIN(IWINDOW)
         CALL LOCATE(2,ISTRT+2,IERR)
         CALL WRTSTR(MSGLN3,38,15,3)
         CALL GETCHAR(0,INCHAR)
      END IF
C
C   IF HELP WANTED, DISPLAY IT AND ASK FOR NEXT USER INPUT.
C   OTHERWISE, REMOVE HIGHLIGHT ON THIS LINE IN ANTICIPATION OF MOVING
C   TO ANOTHER LINE.
C      
      IF (INCHAR.EQ.'1F') THEN
         CALL DSPWIN(HELPFILE)
         GO TO 180
      ELSE IF (FOUND) THEN
         IF (VALTYP.EQ.6) THEN
            IF (INCHAR.NE.'9F') THEN
               CALL DSPREC(I1,ISTRT+1,0,HLDREC(I1),IWIDTH)
            ENDIF   
C         ELSE IF (.NOT.(VALTYP.GE.3.AND.INCHAR.EQ.'7F')) THEN
         ELSE IF (.NOT.((VALTYP.EQ.3.OR.VALTYP.EQ.6.OR.VALTYP.EQ.7)
     +                   .AND.INCHAR.EQ.'7F')) THEN
            CALL DSPREC(I1,ISTRT+1,0,HLDREC(I1),IWIDTH)
         END IF
      END IF
C
C   CHECK IF AN ALPHA KEY IS ENTERED - IF SO, TURN ON SPEED SEARCH.
C
      IF (INCHAR(2:2).EQ.' ') THEN
         IF (INCHAR(1:1).EQ.' '.OR.(INCHAR(1:1).GE.'A'.AND.
     +            INCHAR(1:1).LE.'Z')) THEN
            SRCHKY = INCHAR(1:1)
            IF (VALTYP.EQ.1) THEN
               J = 1
            ELSE IF (VALTYP.EQ.2) THEN
               J = LOWID - 1
            ELSE IF (VALTYP.GE.3) THEN
               J = 0
            END IF
            I1 = 1
            IPAGE = 0
            PREVID = '        '
            CALL LOCATE(23,ISTRT+MSGLEN+1,IERR)
            CALL WRTSTR(SRCHKY,1,15,1)
            CALL LOCATE(22,ISTRT+1,IERR)
            CALL WRTSTR(MSGLN2,18,12,0)
            GO TO 100
         END IF
      END IF
C
C   OTHERWISE, CHECK FOR PAGE, CURSOR, OR OTHER FUNCTION KEYS AND
C   TAKE THE APPROPRIATE ACTION.
C 
      IF (INCHAR.EQ.'DP') THEN
         I1 = I + 1
      ELSE IF (INCHAR.EQ.'UP') THEN
         I1 = 0
      ELSE IF (INCHAR.EQ.'HO') THEN
         I1 = 1
      ELSE IF (INCHAR.EQ.'EN') THEN
         I1 = I
      ELSE IF (INCHAR.EQ.'DA') THEN
         I1 = I1 + 1
      ELSE IF (INCHAR.EQ.'UA') THEN
         I1 = I1 - 1
      ELSE IF (INCHAR.EQ.'2F'.OR.INCHAR.EQ.'RE') THEN
         IF (VALTYP .EQ. 7) THEN
            RTNVAL(1)(1:73) = HLDREC(I1)
         ELSE
            RTNVAL(1)(1:IWIDTH) = HLDREC(I1)
         ENDIF
         GO TO 300
      ELSE IF (INCHAR.EQ.'9F'.AND.VALTYP.EQ.6) THEN
         RTNVAL(1)(1:IWIDTH) = HLDREC(I1)
         ITYPE = 1
         GO TO 300
      ELSE IF (INCHAR.EQ.'7F' .AND. 
     +        (VALTYP.EQ.3.OR.VALTYP.EQ.7)) THEN
         RTNVAL(1)(1:IWIDTH) = HLDREC(I1)
         CALL LOCATE(I1+1,ISTRT+1,IERR)
         CALL WRTSTR(MSGLN6,MSG6LEN,0,4)
200      CONTINUE
         CALL BEEP
         CALL GETCHAR(0,INCHAR)
         IF (INCHAR.EQ.NOUP) THEN
            J = 0
            I1 = 1
            IPAGE = 0
            PREVID = '        '
            GO TO 100
         ELSE IF (INCHAR.EQ.YESUP) THEN
            ITYPE = 1
            GO TO 300
         ELSE
            GO TO 200
         END IF
      ELSE IF (INCHAR.EQ.'4F') THEN
         RTNVAL(1)(1:RECLEN) = ' '
         GO TO 300
      ELSE
         CALL BEEP
         GO TO 180   
      END IF
C
C  IF SELECTED LINE IS OFF THE PAGE, SCROLL PAGE
C
      IF (I1.GT.I) THEN
         IF (I.EQ.22) THEN
            I1 = 1
            GO TO 100
         ELSE
            I1 = I
            CALL BEEP
         END IF
      ELSE IF (I1.LT.1) THEN
         IF (IPAGE.GT.1) THEN
            IPAGE = IPAGE - 2
            I1 = 22
            J = JREC(IPAGE+1) - 1
            PREVID = '        '
            GO TO 100
         ELSE
            I1 = 1
            CALL BEEP
         END IF
      END IF
      GO TO 180  

300   CONTINUE
C
C   CLOSE WINDOW, RESTORE SCREEN AND RETURN
C
      CALL CLOSWIN(IWINDOW,BUFFER(1,IWINDOW))
      RETURN
      END

************************************************************************
      SUBROUTINE DSPREC(I,ICOL,ICOLOR,HLDREC,ILEN)
C
C   ROUTINE TO DISPLAY THE CURRENT RECORD IN NORMAL OR HIGHLIGHTED MODE
C
      CHARACTER*80 HLDREC

      IF (ICOLOR.EQ.0) THEN
         IFG = 0
         IBG = 3
      ELSE IF (ICOLOR.EQ.-1) THEN
         IFG = 0
         IBG = 5
      ELSE 
         IFG = 0
         IBG = 7
      END IF
      CALL LOCATE(I,ICOL,IERR)
      CALL WRTSTR(HLDREC,ILEN,IFG,IBG)
      RETURN
      END
*********************************************************************
      SUBROUTINE NAMSRT(I,HLDREC,SRTBEG,SRTLEN)
C
C   ROUTINE TO SORT THE LAST ENTRY (I) IN THE HOLD ARRAYS INTO THE 
C   PROPER LOCATION IN ALPHABETICAL ORDER BY THE SORT KEY (CONVERT ALL
C   LOWER CASE TO UPPER
C
      CHARACTER*80 HLDREC(23)
      CHARACTER*24 NEWID,OLDID
      INTEGER*2 SRTBEG,SRTLEN
C
      IF (I.LE.1) THEN
         RETURN
      END IF
      I1 = I
      IEND = SRTBEG + SRTLEN - 1
100   CONTINUE
      J = I1 - 1
      NEWID = HLDREC(I1)(SRTBEG:IEND)
      CALL UPPER(NEWID,SRTLEN)
      OLDID = HLDREC(J)(SRTBEG:IEND)
      CALL UPPER(OLDID,SRTLEN)
      IF (NEWID.LT.OLDID) THEN     
         HLDREC(23) = HLDREC(J)
         HLDREC(J) = HLDREC(I1)
         HLDREC(I1) = HLDREC(23)
         I1 = J         
         IF (J.GT.1) THEN
            GO TO 100
         END IF
      END IF
      RETURN
      END
***********************************************************************
      SUBROUTINE UPPER(TEXT,LENGTH)
C
C   ROUTINE TO CONVERT A CHARACTER STRING TO UPPER CASE
C
      CHARACTER*80 TEXT
      CHARACTER*1  FCHAR
C
      DO 100 J = 1,LENGTH
         FCHAR = TEXT(J:J)
         JCHAR = ICHAR(FCHAR)
         IF (JCHAR.GT.96) THEN
            JCHAR = JCHAR - 32
            TEXT(J:J) = CHAR(JCHAR)
         END IF
100   CONTINUE
      RETURN
      END
