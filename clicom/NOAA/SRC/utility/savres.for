$STORAGE:2
C
C      SUBROUTINE SAVRES(OPCODE,MODE,PAGE,FILNAM,BORDER,IERR)
C
C THIS SUBROUTINE IS USED TO SAVE AND RESTORE PAGES OF DISPLAY
C MEMORY TO AND FROM DISK FILES.  IT USES THE FORLIB LIBRARY
C ACSSUB.LIB.  TO CALL:
C
C            CALL SAVRES (OPCODE,MODE,PAGE,FILNAM,BORDER,IERR)
C             WHERE:
C               OPCODE =0 TO SAVE TO A DISK FILE
C                      =1 TO RESTORE FROM A DISK FILE
C               MODE   =0-7 AS DEFINED IN THE IBM LITERATURE
C               PAGE   =0-7 IN MODES 0 AND1
C                      =0-3 IN MODES 2 AND 3
C                      =0   IN ALL OTHER MODES
C               FILNAM =ASCII STRING IN THE STANDARD DOS FILENAME FORMAT
C               BORDER =BORDER COLOR IF DESIRED (-1 IF NOT WANTED)
C               IERR   =0 IF NO ERRORS ENCOUNTERED
C                      =1 IF AN ERROR DETECTED
C
      INTERFACE TO INTEGER*2 FUNCTION SYSTEM [C]
     +      (STRING [REFERENCE])
      CHARACTER*1 STRING
      END

      SUBROUTINE SAVRES(OPCODE,MODE,PAGE,FILNAM,BORDER,IERR)
C
      IMPLICIT INTEGER (A-Z)
      DIMENSION ISIZE(2)
      INTEGER*4 SEGMEN
      INTEGER*2 SYSTEM
      CHARACTER FILNAM*64,DIRCMD*64,PATH*64,FILDIR*32,DSKCMD*4
     +         ,FILEXT*3,FLNAME*8      
      CHARACTER*1 FCB(44),NREC,NAME(8),EXT(3),DISK,DSKNUM(27)
      CHARACTER*2 INCHAR
      EQUIVALENCE (NREC,JREC),(FCB(8),DRIVE),(FCB(9),NAME(1))
      EQUIVALENCE (FCB(17),EXT),(FCB(20),NBLOCK),(FCB(22),LREC)
      EQUIVALENCE (FCB(24),ISIZE),(FCB(28),IDATE),(FCB(40),IREC)
      DATA DSKNUM /' ','A','B','C','D','E','F','G','H','I','J','K','L'
     +            ,'M','N','O','P','Q','R','S','T','U','V','W','X','Y'
     +            ,'Z'/
C
      IERR=0
C
C SET TO INDICATE THAT THIS IS AN EXTENDED FILE CONTROL BLOCK
C
      JREC=-1
      FCB(1)=NREC
C
C   FIND THE END OF THE FILE NAME
C      
      IF (FILNAM.EQ.' ') THEN
         CALL WRTMSG(4,120,12,1,1,' ',0)
         IERR = 1
         GO TO 290
      END IF
      DO 30 I = 1,64
         IF (FILNAM(I:I).EQ.' ') THEN
            GO TO 35
         END IF
         NAMLEN = I
   30 CONTINUE
   35 CONTINUE
C
C   PARSE THE FILE NAME INTO DISK,DIRECTORY,FILE AND EXTENSION
C
      FILDIR = ' '
      FLNAME = ' '
      FILEXT = ' '
      INAME = NAMLEN
      JNAME = 1
      IDIR = 0
      JDIR = 1
      DISK = ' '
      IF (FILNAM(2:2).EQ.':') THEN
         DISK = FILNAM(1:1)
         JNAME = 3
         JDIR = 3
      END IF
      DO 50 I = NAMLEN,JDIR,-1
         IF (FILNAM(I:I).EQ.'.') THEN
            INAME = I - 1
            ILEN = NAMLEN - I 
            IF (ILEN.GT.3) THEN
               CALL WRTMSG(4,121,12,1,1,' ',0)
               IERR = 1
               GO TO 290
            ELSE
               FILEXT(1:ILEN) = FILNAM(I+1:NAMLEN)
            END IF
         ELSE IF (FILNAM(I:I).EQ.'\') THEN
            JNAME = I + 1
            IDIR = I - 1
            FILDIR = FILNAM(JDIR:IDIR)
            GO TO 55
         END IF
   50 CONTINUE
   55 CONTINUE
C   
      IF (INAME-JNAME.GT.7) THEN
         CALL WRTMSG(4,122,12,1,0,' ',0)
         WRITE(*,*) '      - ',FILNAM
         IERR = 1
         CALL WRTMSG(2,202,15,0,0,' ',0)
         CALL GETCHAR(0,INCHAR)
         GO TO 290
      ELSE IF (INAME-JNAME.LT.0) THEN
         CALL WRTMSG(4,123,12,1,1,' ',0)
         IERR = 1
         GO TO 290
      END IF
      FLNAME = FILNAM(JNAME:INAME)
C
C   FIND THE CURRENT DEFAULT DISK DRIVE
C
      IF (DISK.NE.' ') THEN
         CALL GETDSK(NDISK)
      END IF
C
C   FIND THE CURRENT DIRECTORY PATH
C
      IF (IDIR.GT.0) THEN
         CALL GTDIR2(PATH,0,IER)
      END IF
C
C   CHANGE TO THE NEW DRIVE AND DIRECTORY IF INDICATED
C
      IF (DISK.NE.' ') THEN
         DSKCMD = FILNAM(1:2)
         DSKCMD(3:4) = ' 'C
         I1 = SYSTEM (DSKCMD)
      END IF
      IF (IDIR.GT.0) THEN
         NDIR = IDIR - JDIR + 1
         DIRCMD = 'CD '
         DIRCMD(4:NDIR+3) = FILDIR(1:NDIR)
         DIRCMD(NDIR+4:NDIR+5) = ' 'C
         I1 = SYSTEM (DIRCMD)
      END IF
C
C PICK UP DRIVE DESIGNATOR AND PUT IN FCB
C
      JDISK = ICHAR(DISK)
      IF (JDISK.GT.96) THEN
         JDISK = JDISK - 32
         DISK = CHAR(JDISK)
      END IF
      DO 60 K=0,25
      IF (DISK.EQ.DSKNUM(K+1)) THEN
         DRIVE=K
         GO TO 70
      ENDIF
60    CONTINUE
      CALL WRTMSG(4,124,12,1,1,' ',0)
      IERR=1
      GO TO 290
C
C PICK UP FILE NAME AND EXTENSION AND PUT IN FCB
C
70    DO 80 K=1,8
      NAME(K)=FLNAME(K:K)
80    CONTINUE
      DO 85 K=1,3
      EXT(K)=FILEXT(K:K)
85    CONTINUE
C
C INITIALIZE BLOCK AND RECORD IN FCB TO BEGIN AT START OF THE
C SEQUENTIAL FILE
C
      NBLOCK=0
      IREC=0
C
C CHECK FOR VALID MODE
C
      IF(MODE.LT.0.OR.MODE.GT.7) THEN
        CALL WRTMSG(4,125,12,1,1,' ',0)
        IERR=1
        GO TO 290
      ENDIF
      IF(MODE.EQ.7) THEN
C
C SET BUFFER ADDRESS AND SIZE FOR MONOCHROME
C
        SEGMEN=#B000
        OFFSET=0
        SIZE=4096
        GO TO 100
      ENDIF
C
C SEGMENT ADDRESS FOR ALL OTHER MODES IS B800 HEX
C
      SEGMEN=#B800
      IF(MODE.GE.4.AND.MODE.LE.6) THEN
C
C SET ADDRESS AND SIZE FOR MEDIUM RESOLUTION GRAPHICS
C
         OFFSET=0
         SIZE=16384
         GO TO 100
      END IF
      IF(MODE.EQ.2.OR.MODE.EQ.3) THEN
         IF(PAGE.LT.0.OR.PAGE.GT.3) THEN
            CALL WRTMSG(4,126,12,1,1,' ',0)
            IERR=1
            GO TO 290
         END IF
C
C SET ADDRESS AND SIZE FOR 80 COLUMN TEXT
C
         OFFSET=PAGE*4096
         SIZE=4096
         GO TO 100
      END IF
      IF(PAGE.LT.0.OR.PAGE.GT.7) THEN
         CALL WRTMSG(4,126,12,1,1,' ',0)
         IERR=1
         GOTO 290
      END IF
C
C SET ADDRESS AND SIZE FOR 40 COLUMN TEXT
C
      OFFSET=PAGE*2048
      SIZE=2048
100   IF(OPCODE.NE.0.AND.OPCODE.NE.1) THEN
         CALL WRTMSG(4,127,12,1,1,' ',0)
         IERR=1
         GOTO 290
      END IF
C
C IF THIS IS A SAVE, CREATE OR OPEN FILE DEPENDING ON EXISTENCE
C IF THIS IS A RESTORE, DO AN OPEN
C
      IF(OPCODE.EQ.0) THEN
         CALL CRFILE(FCB,IER)
      ELSE
         CALL OPFILE(FCB,IER)
      END IF
      IF (IER.EQ.0) THEN
         CALL WRTMSG(4,128,12,1,1,' ',0)
         IERR=1
         GO TO 290
      END IF
C
C SET LOGICAL RECORD SIZE IN FCB
C
      LREC=128
C
C COMPUTE NUMBER OF RECORDS TO READ OR WRITE
C
      NRECS=SIZE/128
C
C LOOP TO READ OR WRITE NRECS RECORDS
C
      DO 250 KEN=1,NRECS
C
C    SET BUFFER BEGIN ADDRESS IN DISK TRANSFER AREA
C
         CALL STXFRA(INT2(SEGMEN),OFFSET)
C
C    UPDATE BUFFER ADDRESS FOR NEXT READ OR WRITE
C
         OFFSET=OFFSET+128
C
C    IF A SAVE, DO SEQUENTIAL WRITE TO DISK
C    IF A RESTORE, DO SEQUENTIAL READ FROM DISK
C
         IF (OPCODE.EQ.0) THEN
            CALL SEQWRT(FCB,IER)
         ELSE
            CALL SEQRED(FCB,IER)
         END IF
         IF (IER.EQ.0) THEN
            CALL WRTMSG(4,129,12,1,1,' ',0)
            IERR=1
            GO TO 290
         END IF
250   CONTINUE
C
C CLOSE FILE TO ENSURE THAT BUFFERS ARE FLUSHED
C
      CALL CLFILE(FCB,IER)
      IF (IER.EQ.0) THEN
         CALL WRTMSG(4,130,12,1,1,' ',0)
         IERR=1
         GO TO 290
      END IF
C
C   SET THE BORDER COLOR IF REQUESTED
C
290   CONTINUE
      IF (BORDER.GT.-1) THEN
         CALL CLTEXT(0,BORDER,IER)
      END IF
C
C   CHANGE THE DRIVE AND DIRECTORY BACK TO WHAT IT WAS WHEN THE PROGRAM
C   WAS CALLED
C  
      IF (DISK.NE.' ') THEN
         DSKCMD(1:1) = DSKNUM(NDISK+2)
         I1 = SYSTEM (DSKCMD)
      END IF
      IF (IDIR.GT.0) THEN
         DIRCMD(5:64) = PATH(1:60)      
         I1 = SYSTEM(DIRCMD)
      END IF
C      
      RETURN
      END
