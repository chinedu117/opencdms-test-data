$STORAGE:2 
      PROGRAM GRAFINIT
C      
C   ROUTINE TO READ DATAEASE CLIMATE DATA FILES AND REFORMAT THE
C   DATA INTO THE CLICOM APPLICATIONS INTERFACE FORMAT (API) FOR USE BY
C   THE CLICOM GRAPHICS SYSTEM (CGS).  ROUTINE ALSO WRITES THE INITIAL 
C   GRAPH DEFINITION FILE (GDF) FOR NEW GRAPHS TO BE DEFINED.
C   THE ELEMENTS TO BE INCLUDED ARE DEFINED BY THE GDF FOR PREDEFINED 
C   GRAPHS AND BY THE USER FOR NEW GRAPHS.
C
C   NOTICE - THIS PROGRAM REQUIRES FORTRAN VERSION 4.0 OR LATER !
C
C       ** NOTE:  ERRORLEVEL SETTING AND ACTION UPON EXIT
C                 STOP 8 -- ERROR RETURN TO START OF GRAPHICS
C                 STOP 7 -- EXIT GRAPHICS
C                 STOP 6 -- CALL SLIDE DISPLAY ROUTINE
C                 STOP 5 -- MAP
C                 STOP   -- TIMESERIES, SKEWT, WINDROSE
C
C       ** NOTE:  TIME LABEL CONVENTIONS 
C
C  PROGRAM CONTROL VARIABLES
C
$INCLUDE:  'GRFPARM.INC'
$INCLUDE:  'GRAFVAR.INC'
C
C       .. ARRAY BUFFER USED BY SELAREA AND WNDSMRY TO SAVE SPACE
C          MNBUFSZ IS THE MINIMUM ARRAY SIZE REQUIRED BY WNDSMRY FOR BUFFER
C          I1BUF IS A WORK ARRAY USED BY THE ROUTINE DFSTNLST; TO REDUCE 
C          EXECUTABLE SIZE, IT OCCUPIES THE SAME SPACE AS BUFFER
C **DEBUG
C      PARAMETER (MNBUFSZ=51*16*13) 
      PARAMETER (MNBUFSZ=10) 
$INCLUDE:  'SAVBUF.INC'
C
      PARAMETER (MAXVAR=96)
      CHARACTER*18 STRTID, ENDID, RECID, PREVID
      CHARACTER*10 STRTTIME,ENDTIME,RDTIM,HLDTIM,WRTTIM
      CHARACTER*8  STARTSTN,SELECTIONFORM(14)
      CHARACTER*3  TYPEDEF(7)
      CHARACTER*2 RTNFLAG,EXITOPT
      CHARACTER*2 HOURLBL(24)
      CHARACTER*1 DATASOURCE,RTNCODE,SRCCODE(4)
      INTEGER*4   RECCOUNT,NRECCOUNT,IREC
      INTEGER*2 NUMLOOP,NUMVAL(7)
      LOGICAL MEANEXTR,FOUND,RDFLG,HLDFLG,WRTFLG,ELEMFND
C
C  INPUT DATA VARIABLES
C    
      CHARACTER*21 IDKEY
      CHARACTER*8 STNID, FIELD(10),GRAFNAME
      CHARACTER*1 FLAGS(6)  
      REAL*4 VALUE(MAXVAR)
      INTEGER*2 IELEM
      INTEGER*4 NUMEXT
C
C   STORAGE AND OUTPUT DATA VARIABLES
C
      CHARACTER*78 MSGTXT
      CHARACTER*64 HELPFILE
      CHARACTER*28 TITLE,SUBTITLE,ELEMTEXT(MXELEM)
      CHARACTER*20 RECPRT(2)
      CHARACTER*12 MONNAME(13)
      CHARACTER*8 OUTCNT
      CHARACTER*1 NULL
      INTEGER*2 MSGNBR(7)
      LOGICAL APIOPN,ESCFLG
C       .. NRCD AND MAXROW ARE DEFINED IN GRFPARM.INC
      REAL*4 HLDARRAY(NRCD)
      CHARACTER*12 ROWHDR(MAXROW)
      COMMON /GRAFINSV/ HLDARRAY,ROWHDR
C      
C       .. MAXROW, DEFINED IN GRFPARM.INC, IS THE DIMENSION OF LATLIST/LONLIST
C          LATLIST AND LONLIST ARE DEFINED IN ROUTINE SELAREA.  THEY ARE 
C          NOT PASSED AS ARGUMENTS BUT RATHER THE COMMON BLOCK /LTLNSTN/
C          IS INCLUDED IN SELAREA.  THIS ALLOWS I2WRK TO BE PASSED AS AN
C          ARGUMENT TO THE ROUTINES THAT PRODUCE A USER DEFINED STATION
C          SELECTION LIST.  THE ROUTINES THAT USE I2WRK COMPLETE THEIR
C          PROCESSING BEFORE VALUES ARE DEFINED FOR LATLIST AND LONLIST.
C      
C       .. I2WRK IS A WORK ARRAY USED BY THE ROUTINE DFSTNLST; TO REDUCE 
C          EXECUTABLE SIZE, IT OCCUPIES THE SAME SPACE AS LATLIST AND LONLIST
$INCLUDE: 'LTLNSTN.INC'
C      
$INCLUDE: 'VAL1.INC'
$INCLUDE: 'INDEX.INC'
C
      DATA MSGNBR /579,596,548,464,462,409,410/
      DATA SELECTIONFORM /'GETLIMMY','GETLIM10','GETLIMDY','GETLIMSY'
     +    ,'GETLIMHR','GETLIM15','GETLIMHR'
     +    ,'GET1MON','GET110D','GET1DAY','GET1SYN','GET1HLY','GET115M'
     +    ,'GET1HLY'/
      DATA NUMVAL /12,36,31,8,24,96,100/
     +    ,TYPEDEF /'MLY','10D','DLY','SYN','HLY','15M','U-A'/
C       .. M=MAIN DATAEASE          S=SUBSET DATAEASE
C          T=TEMPORARY LOAD FILE    D=KEY ENTRY FILE     
      DATA SRCCODE /'M','S','T','D'/
      DATA HELPFILE /'P:\HELP\GRFINIT2.HLP'/
      DATA APIOPN /.FALSE./
      DATA ESCFLG /.FALSE./
C       .. OPTIONS FLAG WRITTEN TO DATACOM.CON WHEN EXITING TO GRFMN2/134
      DATA EXITOPT/'ZZ'/      
C
C       ** BEGIN PROGRAM CODE  ------------------------------------------------
C
C       ** CHECK THAT ARRAY BUFFER MEETS MINIMUM SIZE REQUIREMENTS OF
C          ROUTINE WNDSMRY; BUFFER IS LOADED FOR GRAPHICS SECTION OF
C          WRTGRAF.  SINCE NO GRAPHICS ARE USED IN GRAFINIT, THIS ARRAY
C          SPACE IS USED BY SELAREA AND WNDSMRY TO SAVE SPACE.
C
      IF (MNBUFSZ.GT.IBUFD) THEN
         CALL WRTMSG(3,596,12,1,1,' ',0)
         CALL LOCATE(24,0,IERR)
         STOP 7
      ENDIF         
C
      NULL = CHAR(0)
      CALL SETMOD(3,IERR)
C
C   ASK THE USER WHAT GRAPH CATEGORY THEY WOULD LIKE AND SET OR  
C   REQUEST THE OBS-TYPE AS APPROPRIATE
C
20    CONTINUE
      DO 30 I = 1,MXELEM
         GRAFELEM(I) = 0
30    CONTINUE         
      NUMCOL = 0
      PLTWID = 0
      NUMPLT = 0
      RTNFLAG = '  '
   40 CONTINUE      
      CALL PICKGRAF(IGRAPH,PLTWID,ITYPE,GRAFNAME,NBRELEM,RTNCODE)
      IF (RTNCODE.EQ.'1') THEN
C          .. EXIT -- NO SELECTION MADE FROM MENU
         CALL LOCATE(24,0,IERR)
         STOP 7
      ELSE IF (RTNCODE.EQ.'2') THEN
C          .. EXIT TO DISPLAY SAVED GRAPHICS SCREEN
         CALL LOCATE(24,0,IERR)
         STOP 6
      END IF
C
C       ** UPPER AIR DATA NOT ALLOWED WITH TIMESERIES PLOT
C
      IF (IGRAPH.EQ.1 .AND. ITYPE.EQ.7) THEN
         CALL WRTMSG(3,399,12,1,0,' ',0)
         GO TO 40
      ENDIF         
C
C       ** INITIAL THE FIELDS FOR STATION AND TIME RANGE
C
      DO 45 I=1,10
         FIELD(I) = ' '
   45 CONTINUE        
C
C       ** REVISE NUMBER OF WIND ROSE DIRECTIONS FOR PREDEFINED GRAPH
C
      IF (IGRAPH.EQ.4 .AND. GRAFNAME.NE.' ') THEN
         CALL GTNWRDIR(PLTWID,RTNCODE)
         IF (RTNCODE.NE.'0') GO TO 20
      ENDIF         
C
      NCOLOLD = NUMCOL
      NPLTOLD = NUMPLT
C
      OBSTYPE = TYPEDEF(ITYPE)
      NUMLINE = NUMVAL(ITYPE)
      NUMLOOP = NUMVAL(ITYPE)
C
C       ** FOR HOURLY AND SYNOPTIC DATA READ HOUR LABEL VALUES FROM DATAQC.PRM
C
      IF (ITYPE.EQ.4 .OR. ITYPE.EQ.5) THEN
         CALL RDHRLBL(ITYPE,HOURLBL,RTNCODE)
         IF (RTNCODE.NE.'0') GO TO 20
      ENDIF   
C
C       ** DETERMINE THE ELEMENTS TO BE SELECTED
C
50    CONTINUE
      IF (IGRAPH.EQ.3) THEN
         GRAFELEM(1) = 301
         GRAFELEM(2) = 302
         GRAFELEM(3) = 303
         GRAFELEM(4) = 304
         GRAFELEM(5) = 305
         GRAFELEM(6) = 306
         NBRELEM = 6
         CALL SETELEM(ITYPE,IGRAPH,GRAFELEM,ELEMTEXT,NBRELEM,RTNFLAG)
      ELSE 
         CALL SETELEM(ITYPE,IGRAPH,GRAFELEM,ELEMTEXT,NBRELEM,RTNFLAG)
      END IF
      IF (NBRELEM.EQ.0 .OR. RTNFLAG.EQ.'4F' .OR. RTNFLAG.EQ.'ES') THEN
         GO TO 20
      END IF
      DO 100 I1 = 1,NBRELEM
         IF (GRAFELEM(I1).GT.1000) THEN
            MEANEXTR = .TRUE.
         END IF
100   CONTINUE
C
C   ASK USER FOR DATA SELECTION INFORMATION (RANGE OF STNS AND DATES)
C   SELECTION DEPENDS UPON THE GRAPH CATEGORY AND OBS-TYPE WANTED
C
120   CONTINUE
      CALL CLS
C
C   FIRST, ASK USER FOR RANGE OF STATION-IDS AND DATES FOR A MAP
C   ELSE, ASK USER FOR STATION AND TIME RANGE TO USE FOR OTHER GRAPH TYPES
C 
      IF (IGRAPH.EQ.2) THEN
         RTNFLAG = 'SS'
         CALL LOCATE(9,1,IERR)
         IF (NBRELEM.GT.1) THEN
            CALL GETFRM(SELECTIONFORM(ITYPE+7),HELPFILE,FIELD,8,RTNFLAG)
            ICNTRL = 1
         ELSE
            CALL GETFRM(SELECTIONFORM(ITYPE),HELPFILE,FIELD,8,RTNFLAG)
            ICNTRL = 0
         END IF
      ELSE
         ICNTRL = 0
         RTNFLAG = 'SS'
         CALL LOCATE(3,1,IERR)
         CALL GETFRM(SELECTIONFORM(ITYPE),HELPFILE,FIELD,8,RTNFLAG)
      END IF
C
125   CONTINUE
      IF (RTNFLAG.EQ.'4F') THEN
         GO TO 20
      END IF
C
C   SET THE START AND END ID'S USING THE VALUES FROM FIELDS THAT ARE
C   APPROPRIATE FOR THE OBS-TYPE AND GRAPH TYPE (ICNTRL) SPECIFIED.
C
      MSGTXT = ' '
      CALL SETRANGE(ITYPE,ICNTRL,FIELD,
     +              HOURLBL,STRTID,ENDID,NMSG,MSGTXT,RTNFLAG)
      IF (RTNFLAG.EQ.'ER') THEN
         LTXT = LNG(MSGTXT)
         CALL WRTMSG(3,NMSG,12,1,1,MSGTXT,LTXT)
         GO TO 120
      END IF
C
      IF (IGRAPH.EQ.2 .AND. NBRELEM.EQ.1) THEN
C
C          .. MAP -- ONE ELEMENT WITH A RANGE OF TIMES 
C             MAKE SURE THE NUMBER OF VALUES WANTED IS LESS THEN MXELEM-2.
         CALL MAXITEM(ITYPE,MXELEM,STRTID,ENDID,RTNCODE)
         IF (RTNCODE.NE.'0') THEN
            RTNFLAG = 'SS'
            CALL LOCATE(9,1,IERR)
            CALL GETFRM(SELECTIONFORM(ITYPE),HELPFILE,FIELD,8,
     +                  RTNFLAG)  
            GO TO 125
         END IF
      END IF
C
C       ** SET INTERNAL LOOP START AND END SELECTION VARIABLES
C          JSTRT AND JEND ARE USED ONLY FOR MAP GRAPHICS
C
      STRTTIME = STRTID(9:18)
      ENDTIME = ENDID(9:18) 
      STARTSTN = STRTID(1:8)
      IF (ITYPE.LE.2) THEN
C          .. MONTHLY AND 10D DATA      
         READ(STRTID,'(12X,I2)') JSTRT
         READ(ENDID,'(12X,I2)') JEND
         LSTCHR = 12
      ELSE IF (ITYPE.EQ.3) THEN
C          .. DAILY DATA      
         READ(STRTID,'(14X,I2)') JSTRT
         READ(ENDID,'(14X,I2)') JEND
         LSTCHR = 14
      ELSE IF (ITYPE.LT.7) THEN
C          .. SYNOPTIC, HOURLY, 15 MINUTE DATA
         READ(STRTID,'(16X,I2)') JSTRT
         READ(ENDID,'(16X,I2)') JEND
         LSTCHR = 16
      ELSE
C          .. UPPER-AIR DATA -- NOT ALLOWED FOR MAP SO NO JSTRT,JEND         
         LSTCHR = 18
      END IF
      IF (IGRAPH.EQ.2) THEN
         IF (NBRELEM.EQ.1) THEN
            NUMCOL = JEND - JSTRT + 3
         ELSE
            NUMCOL = NBRELEM + 2
         END IF
      ELSE 
C          .. NON-MAP GRAPHICS -- JSTRT,JEND NOT USED      
         JSTRT = 0
         JEND = 0
         IF (IGRAPH.EQ.4) THEN
            NUMCOL = PLTWID   
         ELSE
            NUMCOL = NBRELEM   
         END IF
      END IF
C
C       ** CALCULATE THE ROW DIMENSION FOR DATA ARRAYS
C
      NROWDIM = MIN0(NRCD/NUMCOL,MAXROW)      
      MXDATCOL=NUMCOL
      MXDATROW=NROWDIM
C
C   FOR A MAP, ASK USER FOR THE AREA WANTED. A LIST OF STATIONS WITHIN
C   THE LAT AND LON BOUNDARIES IS GENERATED AUTOMATICALLY.
C 
      CALL CLS
      CALL LOCATE(0,5,IERR)
      IF (IGRAPH.EQ.2) THEN
C          .. BUFFER(I*4) IS EQUIVALENCED TO I1BUF(I*1) -- INITIAL AS I*1      
         DO 128 I=1,MAXBYT
            I1BUF(I) = 0
  128    CONTINUE         
         CALL SELAREA(I1BUF,MAXBYT,LOWLAT,HILAT,LOWLON,HILON,
     +                MXDATROW,RTNFLAG)
C          .. BUFFER(I*4) IS EQUIVALENCED TO I1BUF(I*1) -- INITIAL AS I*4
         DO 129 I=1,IBUFD
            BUFFER(I) = 0
  129    CONTINUE         
         IF (RTNFLAG.EQ.'4F') THEN
            GO TO 20 
         END IF
         CALL LOCATE(9,1,IERR)
      END IF
C
C   DETERMINE THE SOURCE OF THE INPUT DATA TO BE USED
C 
130   CONTINUE
      CALL LOCATE(12,20,IERR)
      CALL GETMNU('DATASOURCE3 ','  ',ISOURCE)
      IF (ISOURCE.EQ.0) THEN
         GO TO 120
      ELSE 
         DATASOURCE = SRCCODE(ISOURCE)
      END IF
C
C       **  WRITE OUT THE GRAPH DEFINITION FILE (*.GDF)
C
      CALL CLS
      CALL LOCATE(0,5,IERR)
      IF (GRAFNAME.EQ.' ') THEN
         CALL GRAFDFLT
      ELSE IF (IGRAPH.LE.2) THEN
         CALL GRAFMOD(NCOLOLD,NPLTOLD)   
      END IF
      ITEMP=0
      CALL WRTGRAF(GRAFNAME,ITYPE,ITEMP,RTNFLAG)
      IF (RTNFLAG.EQ.'4F') THEN
         GO TO 50
      END IF
C
C   INITIALIZE
C
      PREVID = '        0000000000'
      NRECCOUNT = 0          
      RECCOUNT = 0
      MONTH = 0
      DAY = 0
      HOUR = 0
      NUMSTN = 0
      CALL GETMON(MONNAME,12)
      IF (IGRAPH.EQ.2) THEN
C          .. MAP -- ACTUAL NUMBER OF ROWS IS CURRENTLY UNKNOWN
C                    INITIAL ARRAY TO MAX ROWS ALLOWED
         NUMROW=MXDATROW
      ELSE
C          .. TIMESERIES,SKEWT,WINDROSE--NUMBER OF ROWS DEPENDS ON DATA TYPE   
         NUMROW=NUMLOOP
      ENDIF      
      CALL INITHLD(HLDARRAY,MXDATCOL,NUMROW,NUMCOL)
C
C  FOR TIME SERIES PLOTS, SET ROW HEADER TEXT TO APPROPRIATE TIME VALUES 
C
      IF (IGRAPH.EQ.1) THEN
         DO 160 I1 = 1,NUMLOOP
            IF (ITYPE.EQ.1) THEN
C                .. MONTHLY DATA            
               ROWHDR(I1) = MONNAME(I1)
            ELSE IF (ITYPE.EQ.2) THEN
C                .. 10 DAY DATA            
C               IF (MOD(I1,3).EQ.2) THEN
               IF (MOD(I1,3).EQ.1) THEN
                  J1 = (I1 / 3) + 1
                  ROWHDR(I1) = MONNAME(J1)
               ELSE
                  ROWHDR(I1) = ' '
               END IF
            ELSE IF (ITYPE.EQ.4) THEN
C                .. SYNOPTIC DATA
               ROWHDR(I1) = HOURLBL(I1)
            ELSE IF (ITYPE.EQ.5) THEN
C                .. HOURLY DATA
               ROWHDR(I1) = HOURLBL(I1)
            ELSE
C                .. DAILY, 15 MINUTE DATA
               WRITE(ROWHDR(I1),'(I2)') I1
            END IF
160      CONTINUE
      END IF
C
C   SET COLUMN HEADER TEXT TO ELEMENT DESCRIPTIONS. FOR WIND ROSE
C   SET IT TO POINT ABBREVIATIONS (N,NE,NNE, ETC)
C
      IF (IGRAPH.EQ.4) THEN
         IF (NUMCOL.EQ.8) THEN
            NMSG=563
         ELSE
            NMSG=378
         ENDIF
         CALL GETMSG(NMSG,MSGTXT)
         CALL GETMSG(999,MSGTXT)
         CALL PARSE1(MSGTXT,78,NUMCOL,28,COLHDR,RTNCODE)
      ELSE
         COLHDR(1) = ' '
         COLHDR(2) = ' '
         DO 170 I1 = 1,NBRELEM
            IF (IGRAPH.EQ.2) THEN
               COLHDR(I1+2) = ELEMTEXT(I1)
            ELSE 
               COLHDR(I1) = ELEMTEXT(I1)
            END IF
170      CONTINUE
      END IF
C
C   OPEN THE INPUT AND OUTPUT DATA FILES 
C
      RTNFLAG = ' '
      IF (DATASOURCE.EQ.'D') THEN
C          .. DATASOURCE = D --- KEY ENTRY FILE      
         CALL OPENQC(ITYPE,OBSTYPE,RTNFLAG)
         IF (RTNFLAG.NE.'4F') THEN
            READ(19,REC=1) DELKEY,BGNIDX,NUMIDX
            IF (NUMIDX.EQ.1) THEN
               CALL WRTMSG(3,100,12,1,1,' ',0)
               GO TO 20            
            END IF
         ENDIF
      ELSE IF (DATASOURCE.EQ.'T') THEN
C          .. DATASOURCE = T --- TEMPORARY LOAD FILE      
         CALL OPENLD(OBSTYPE,RTNFLAG)
      ELSE
C          .. DATASOURCE = M/S --- MAIN/SUBSET DATAEASE FILE      
         CALL OPENPOS(OBSTYPE,DATASOURCE,STARTSTN,STRTTIME)
      END IF
      IF (RTNFLAG.EQ.'4F') THEN
         CALL CLS
         GO TO 130
      END IF
C
C   OPEN THE APPROPRIATE MEANS/EXTREMES FILE IF NECESSARY
C
      IF (MEANEXTR) THEN
         CALL OPENEXT(ITYPE,NUMEXT,MEANEXTR)
      END IF   
C
C   FOR MAP, IF MULTIPLE ELEMENTS,  SET THE TITLE TO THE DATE AND LEAVE 
C   COLUMN HEADERS AS ELEMENTS.  IF ONE ELEMENT AND MULTIPLE DATES, SET 
C   THE TITLE TO THE ELEMENT NAME AND SET THE COLUMN HEADERS TO EACH OF
C   THE DATE/TIMES WANTED.  
C
      IF (IGRAPH.EQ.2) THEN
         IF (NBRELEM.GT.1) THEN
            CALL SPELDATE(ITYPE,0,STRTTIME,MONNAME,TITLE,28)
         ELSE
            TITLE = COLHDR(3)
            CALL BLDTIMES(ITYPE,STRTTIME,ENDTIME,MONNAME,COLHDR)
         END IF            
      END IF
C
C  WRITE THE RUNNING TOTAL LINE
C
      MSGTXT = ' '
      CALL GETMSG(561,MSGTXT)
      CALL GETMSG(999,MSGTXT)
      CALL PARSE1(MSGTXT,78,2,20,RECPRT,RTNCODE)
      NCPRT1=LNG(RECPRT(1))+2
      MSGTXT = ' '
      MSGTXT(2:)=RECPRT(1)
      MSGTXT(NCPRT1+10:)=RECPRT(2)
      NCPRT2=LNG(MSGTXT)+1
      CALL CLRMSG(1)
      CALL LOCATE(24,0,IERR)
      CALL WRTSTR(MSGTXT,NCPRT2,14,0)
C
C  LOOP TO PROCESS THE DATA RECORDS ------------------------------------------
C
      NMSG    = 0
      IREC    = 0
      RDFLG   = .TRUE.
      HLDTIM  = ' '
      LSTTCH  = LSTCHR-8
  500 CONTINUE      
         IF (RDFLG) THEN
C
C             .. READ NEXT DATA RECORD         
            IREC = IREC + 1
            CALL RDDATID(DATASOURCE,OBSTYPE,IREC,   
     +             IDKEY,RECID,STNID,IELEM,LVLNUM,FLAGS,VALUE,RTNCODE)
            RDTIM = RECID(9:18)
            IF (RTNCODE.EQ.'0') THEN
C
C                .. WRITE NUMBER OF RECORDS READ TO SCREEN            
               NRECCOUNT = NRECCOUNT + 1
               CALL LOCATE(24,NCPRT1,IERR)
               WRITE(OUTCNT,'(I7,1X)') NRECCOUNT
               OUTCNT(8:8) = CHAR(0)
               CALL CWRITE(OUTCNT,12,IERR)
            ENDIF   
C
C             .. DETERMINE IF RECORD CONTAINS A REQUESTED ELEMENT
            FOUND = .TRUE.
            IF (DATASOURCE.NE.'D'.AND.ITYPE.NE.7) THEN
               JCOL = 0
               DO 240 J = 1,NBRELEM
                  IF (IELEM.EQ.GRAFELEM(J)) THEN
                     JCOL = J
                     GO TO 245
                  END IF
240            CONTINUE    
245            CONTINUE
               FOUND = JCOL.GT.0
            END IF
         ENDIF   
C
C          .. DETERMINE IF RECORD READ IS WITHIN RANGE OF STATIONS AND DATES 
C             WANTED.  IF NOT, SKIP IT.
         IF (RTNCODE.EQ.'1' .OR. 
     +      RECID(1:LSTCHR).GT.ENDID(1:LSTCHR)) THEN
            GO TO 610
         ELSE IF (RECID(1:LSTCHR).LT.STRTID(1:LSTCHR)   .OR.
     +            RDTIM(1:LSTTCH).LT.STRTTIME(1:LSTTCH) .OR.
     +            RDTIM(1:LSTTCH).GT.ENDTIME(1:LSTTCH)) THEN
            GO TO 600
         END IF
C         
         WRTFLG = .FALSE.
         RDFLG  = .FALSE.
         HLDFLG = .FALSE.
         IF (IGRAPH.EQ.2) THEN
C 
C             .. MAP
C                DETERMINE IF STATION IS INCLUDED IN THE MAP STATION LIST
C                ALL DATA SELECTED IS STORED IN A SINGLE FRAME SO DATA IS 
C                ACCUMULATED UNTIL EOF IS READ.
            CALL CHKSTN(STNID,STNLIST,ISTN,MXDATROW,RTNCODE)
            HLDFLG = RTNCODE.EQ.'0'
            RDFLG  = .TRUE.
         ELSE IF (IGRAPH.EQ.3 .OR. IGRAPH.EQ.4) THEN
C
C             .. SKEWT AND WINDROSE
C                SKEWT -- THE STATION AND DATE INFORMATION DETERMINE
C                         FRAME BREAKS.
C                WIND ROSE -- ALL DATA IS ACCUMULATED AND PASSED TO THE 
C                             WINDROSE ROUTINE ONE FRAME AT A TIME.  IT RUNS
C                             THRU THE ENTIRE PERIOD FOR EACH STATION AND
C                             WRITES THE DATA OUT TO THE API FILE ITSELF.
            IF (FOUND) THEN
               IF (RECID.NE.PREVID) THEN
                  IF (PREVID.NE.'        0000000000') THEN
                     WRTFLG=.TRUE.
                  ELSE
                     PREVID=RECID
                  ENDIF
               ENDIF
               HLDFLG = .TRUE.
            ENDIF
            RDFLG = .TRUE.    
         ELSE
C
C             .. TIMESERIES                           
C                THE STATION AND DATE INFORMATION DETERMINE FRAME BREAKS.
C                MISSING TIME RECORDS FOR A STATION ARE WRITTEN 
            IF (PREVID.EQ.'        0000000000') THEN
               WRTTIM = RDTIM
               PREVID = RECID
            ENDIF
            IF (STNID.NE.PREVID(1:8)) THEN
C                .. NEW STATION
               WRTFLG = .TRUE.
               WRTTIM = RDTIM
            ELSE IF (HLDTIM(1:LSTTCH).EQ.WRTTIM(1:LSTTCH) .AND.
     +               RECID.NE.PREVID) THEN
C
C                .. WRITE VALUES TO FILE           
               WRTFLG = .TRUE.
               CALL GTNXTTIM(ITYPE,WRTTIM)
            ELSE IF (RDTIM(1:LSTTCH).EQ.WRTTIM(1:LSTTCH)) THEN
C
C                .. STORE VALUES
               RDFLG  = .TRUE.
               HLDFLG = .TRUE.                    
               HLDTIM = RDTIM
            ELSE
C 
C                .. MISSING RECORD
               PREVID(9:18)  = WRTTIM(1:LSTTCH)   
               HLDTIM        = WRTTIM
            ENDIF 
         ENDIF 
C
         IF (WRTFLG) THEN
            IF (IGRAPH.EQ.4) THEN
C
C                .. FOR WIND ROSES - PASS ACCUMULATED DATA TO WNDSMRY
               RTNCODE = '0'
               CALL WNDSMRY(BUFFER,IBUFD,PREVID,HLDARRAY,MXDATCOL,
     +                      GRAFELEM,ITYPE,NUMLOOP,MONNAME,TITLE
     +                     ,SUBTITLE,COLHDR,ROWHDR,NUMCOL,RTNCODE)
            ELSE
C
C                .. FOR OTHER GRAPHICS -- 1=TIMESERIES, 3=SKEWT
C
C                .. READ MEANS/EXTREMES IF THEY HAVE BEEN REQUESTED
               IF (MEANEXTR) THEN
                  CALL SETLOOP(ITYPE,PREVID,STRTTIME,ENDTIME,NUMLOOP
     +                        ,ISTRT,IEND)
                  CALL RDEXTR(ITYPE,GRAFELEM,PREVID,HLDARRAY
     +                       ,MXDATCOL,NBRELEM,NUMEXT,ISTRT,IEND,NUMSTN)
               END IF
C
C                .. SET TITLE AND SUBTITLE TO STATION NAME AND DATE
               CALL SETTITLE(ITYPE,PREVID,MONNAME,TITLE,SUBTITLE)
C
C                .. DETERMINE THE NUMBER OF RECORDS IN THE DATA FRAME
C                   IF DAILY DATA CALCULATE THE NUMBER OF DAYS IN THE MONTH
               NUMROW=NUMLOOP 
               IF (ITYPE.EQ.3) THEN
                  CALL CDAYMON(PREVID(9:),NUMROW)
               ENDIF   
C               
C                .. WRITE THE ACCUMULATED DATA TO THE OUTPUT API FILE
               CALL WRTFRAME(IGRAPH,TITLE,SUBTITLE,COLHDR,ROWHDR,
     +                       HLDARRAY,MXDATCOL,NUMCOL,NUMROW,RTNCODE)
               APIOPN = .TRUE.
            END IF
            IF (RTNCODE.NE.'0') THEN
               READ(RTNCODE,'(I1)') I
               I = MIN0(I,7)
               NMSG = MSGNBR(I)
               ESCFLG = .TRUE.
               GO TO 700
            ENDIF   
C
C             .. RESET HLDARRAY TO ALL MISSING TO BEGIN NEW ACCUMULATION
            CALL INITHLD(HLDARRAY,MXDATCOL,NUMLOOP,NUMCOL)
            PREVID = RECID
         END IF
         IF (HLDFLG .AND. FOUND) THEN
            IF (IGRAPH.EQ.2.AND.STNID.NE.PREVID(1:8)) THEN
               NUMSTN = NUMSTN + 1
               PREVID = RECID
               IF (MEANEXTR) THEN
C                   .. READ THE MEANS/EXTREMES FOR THIS STATION/DATE
                  CALL RDEXTR(ITYPE,GRAFELEM,RECID,HLDARRAY
     +                       ,MXDATCOL,NBRELEM,NUMEXT,JSTRT,JEND,NUMSTN)
               END IF
            ENDIF
C
C             .. WRITE THE INFORMATION FROM THE CURRENT INPUT DATA RECORD
C                INTO THE APPROPRIATE COLUMN(S) OF HLDARRAY.
            CALL STRVALS(DATASOURCE,ITYPE,IGRAPH,RECID,STRTTIME
     +             ,ENDTIME,JSTRT,JEND,JCOL,RECNUM,IDKEY,NBRELEM,NUMLOOP
     +             ,ROWHDR,GRAFELEM,LATLIST,LONLIST,VALUE,FLAGS
     +             ,HLDARRAY,MXDATCOL,MAXVAR,LVLNUM,ISTN,NUMSTN,ELEMFND)

C
C             .. WRITE THE CURRENT COUNT OF RECORDS USED TO SCREEN
            IF (ELEMFND) THEN
               RECCOUNT = RECCOUNT + 1
               CALL LOCATE(24,NCPRT2,IERR)
               WRITE(OUTCNT,'(I7,1X)') RECCOUNT
               OUTCNT(8:8) = CHAR(0)
               CALL CWRITE(OUTCNT,12,IERR)
            ENDIF
         ENDIF   
600   CONTINUE   
      CALL ESCQUIT(*605)
      GO TO 500
605   CONTINUE   
      ESCFLG = .TRUE.  
610   CONTINUE
C
C   WRITE OUT THE FINAL CONTENTS OF THE HOLD ARRAY BEFORE STOPPING
C
      IF (.NOT.ESCFLG .AND. RECCOUNT.GT.0) THEN
C 
C          .. FIRST WRITE OUT INFO IF MAP
C
         IF (IGRAPH.EQ.2) THEN
            IF (NUMSTN.GT.0) THEN
               NUMROW=NUMSTN       
               SUBTITLE = ' '        
               CALL WRTFRAME(IGRAPH,TITLE,SUBTITLE,COLHDR,ROWHDR,
     +                       HLDARRAY,MXDATCOL,NUMCOL,NUMROW,RTNCODE)
               APIOPN = .TRUE.
            ELSE
               RTNCODE = '3'
            ENDIF   
C
C          .. ELSE WRITE OUT INFO FOR WIND ROSE
C
         ELSE IF (IGRAPH.EQ.4) THEN
            RTNCODE = '1'
            CALL WNDSMRY(BUFFER,IBUFD,PREVID,HLDARRAY,MXDATCOL,
     +                   GRAFELEM,ITYPE,NUMLOOP,MONNAME,TITLE
     +                  ,SUBTITLE,COLHDR,ROWHDR,NUMCOL,RTNCODE)
            IF (RTNCODE.NE.'3') APIOPN = .TRUE.
C
C          .. ELSE WRITE OUT INFO FOR OTHER GRAPHS--TIMESERIES,SKEWT
C
         ELSE
            IF (MEANEXTR) THEN
C                .. READ THE MEANS/EXTREMES INFORMATION FOR THIS STATION/DATE
               CALL SETLOOP(ITYPE,PREVID,STRTTIME,ENDTIME,NUMLOOP,ISTRT
     +                     ,IEND)
               CALL RDEXTR(ITYPE,GRAFELEM,PREVID,HLDARRAY
     +                    ,MXDATCOL,NBRELEM,NUMEXT,ISTRT,IEND,NUMSTN)
            END IF
            CALL SETTITLE(ITYPE,PREVID,MONNAME,TITLE,SUBTITLE)
            NUMROW=NUMLOOP 
            IF (ITYPE.EQ.3) THEN
               CALL CDAYMON(PREVID(9:),NUMROW)
            ENDIF   
            CALL WRTFRAME(IGRAPH,TITLE,SUBTITLE,COLHDR,ROWHDR,HLDARRAY,
     +                    MXDATCOL,NUMCOL,NUMROW,RTNCODE)
            APIOPN = .TRUE.
         END IF
         IF (RTNCODE.NE.'0') THEN
            READ(RTNCODE,'(I1)') I
            I = MIN0(I,7)
            NMSG = MSGNBR(I)
            ESCFLG = .TRUE.
            GO TO 700
         ENDIF   
      END IF
C
C   CLOSE DATA FILES, WRITE FILE DATACOM.CON FOR GRFMN2/134,  AND STOP
C
  700 CONTINUE
      IF (DATASOURCE.EQ.'D') THEN
         CLOSE (19)
         CLOSE (20)
      ELSE
         CLOSE (25)
      END IF
      IF (MEANEXTR) THEN
         CLOSE (31)
      END IF   
C       .. CLOSE .API FILE ONLY IF DATA WAS WRITTEN TO FILE
      IF (APIOPN) CALL ENDFRAME(IGRAPH,NUMCOL)
      
      CALL LOCATE(23,0,IERR)
      IF (ESCFLG) THEN
         IF (NMSG.GT.0) THEN
            CALL WRTMSG(4,NMSG,12,0,0,' ',0)
         ENDIF         
         NMSG = 603
         MSGTXT = ' '
         LENMSG = 0
         GO TO 900
      ELSE IF (RECCOUNT.GT.0) THEN
         IF (IGRAPH.EQ.2) THEN
C  
C             .. PLOT IS MAP      
            CALL WRTDCON(0,0,EXITOPT,RTNCODE)
            IF (RTNCODE.NE.'0') THEN
               NMSG = 192
               MSGTXT = '  DATACOM.CON'
               LENMSG = 13
               GO TO 900
            ENDIF            
            STOP 5
         ELSE   
C
C             .. PLOT IS TIMESERIES, SKEWT, OR WINDROSE      
            CALL WRTDCON(0,0,EXITOPT,RTNCODE)
            IF (RTNCODE.NE.'0') THEN
               NMSG = 192
               MSGTXT = '  DATACOM.CON'
               LENMSG = 13
               GO TO 900
            ENDIF            
            STOP ' ' 
         ENDIF   
      ELSE      
C
C          .. NO DATA FOUND FOR REQUESTED STATIONS OR TIMES       
         NMSG = 548
         MSGTXT = ' '
         LENMSG = 0
         GO TO 900
      ENDIF   
C
C       .. ERROR STOP -- RETURN TO INITIAL GRAPHICS MENU         
  900 CONTINUE
         CALL WRTMSG(3,NMSG,12,1,1,MSGTXT,LENMSG)
         CALL LOCATE(23,0,IERR)
         STOP 8
C
      END

**********************************************************************
      SUBROUTINE RDDATID(DATASOURCE,OBSTYPE,IREC,   
     +             IDKEY,RECID,STNID,IELEM,LVLNUM,FLAGS,VALUE,RTNCODE)
C
      PARAMETER (MAXVAR=96)
      CHARACTER*21 IDKEY
      CHARACTER*18 RECID
      CHARACTER*8  STNID
      CHARACTER*3  OBSTYPE
      CHARACTER*1  DATASOURCE,RTNCODE,FLAGS(6)  
      REAL*4       VALUE(MAXVAR)
      INTEGER*4    IREC
      INTEGER*2    IELEM,LVLNUM
C
$INCLUDE: 'INDEX.INC'      
C      
      CHARACTER*1 FLAG1(MAXVAR)  
      INTEGER*2   DDSID,YEAR,MONTH,DAY,HOUR,NUMLVL
C     
      IF (DATASOURCE.EQ.'D') THEN
         RTNCODE = '1'
         I = BGNIDX + IREC - 1
         IF (I.LE.NUMIDX) THEN
            READ(19,REC=I,ERR=200) DELKEY,IDKEY,RECNUM
            RTNCODE = '0'
            STNID       = IDKEY(1:8)
            RECID(1:8)  = IDKEY(1:8)
            RECID(9:18) = IDKEY(12:21)
         END IF
      ELSE 
         IF (OBSTYPE.EQ.'MLY') THEN
            CALL READMLY(DDSID,STNID,IELEM,YEAR,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'10D') THEN
            CALL READ10D(DDSID,STNID,IELEM,YEAR,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'DLY') THEN
            CALL READDLY(DDSID,STNID,IELEM,YEAR,MONTH,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'SYN') THEN
            CALL READSYN(DDSID,STNID,IELEM,YEAR,MONTH,DAY,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'HLY') THEN
            CALL READHLY(DDSID,STNID,IELEM,YEAR,MONTH,DAY,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'15M') THEN
            CALL READ15M(DDSID,STNID,IELEM,YEAR,MONTH,DAY,VALUE,FLAG1
     +                  ,RTNCODE)
         ELSE IF (OBSTYPE.EQ.'U-A') THEN
            CALL READUA(DDSID,STNID,YEAR,MONTH,DAY,HOUR,NUMLVL,LVLNUM
     +          ,VALUE(1),VALUE(2),VALUE(3),VALUE(4),VALUE(5),VALUE(6)
     +          ,FLAGS,RTNCODE)
         END IF
         WRITE(RECID,'(A8,I4.4,3I2.2)') STNID,YEAR,MONTH,DAY,HOUR
      END IF
200   CONTINUE
      RETURN
      END   
**********************************************************************
      SUBROUTINE INITHLD(HLDARRAY,MXDATCOL,NUMROW,NUMCOL)
C
      REAL*4 HLDARRAY(MXDATCOL,*)
C
      DO 20 I1 = 1,NUMROW
         DO 20 J1 = 1,NUMCOL
            HLDARRAY(J1,I1) = -99999.
   20 CONTINUE
C
      RETURN
      END        
**********************************************************************

      SUBROUTINE SETLOOP(ITYPE,PREVID,STRTTIME,ENDTIME,NUMLOOP,ISTRT
     +                   ,IEND)
C
C   ROUTINE TO SET THE TIME LOOP LIMITS.  THEY MUST BE SHORTENED IF THE
C   CURRENT DATE IS ONE OF THE DATE LIMITS.  THIS ALLOWS USERS TO 
C   SELECT THE SMALLEST RANGE OF TIMES POSSIBLE (E.G. DAYS IN DAILY DATA)
C
      CHARACTER*18 PREVID
      CHARACTER*10 STRTTIME,ENDTIME 

      ISTRT = 1
      IEND = NUMLOOP
      IF (ITYPE.LE.2) THEN
C          .. MONTHLY AND 10 DAY DATA -- MONTH RANGE= 1-12 AND 1-36
         IF (PREVID(9:12).EQ.STRTTIME(1:4)) THEN
            READ(STRTTIME,'(4X,I2)') ISTRT 
         END IF
         IF (PREVID(9:12).EQ.ENDTIME(1:4)) THEN
            READ(ENDTIME,'(4X,I2)') IEND 
         END IF
      ELSE IF (ITYPE.EQ.3) THEN
C          .. DAILY DATA -- DAY RANGE= 1 TO 28-31
         IF (PREVID(9:14).EQ.STRTTIME(1:6)) THEN
            READ(STRTTIME,'(6X,I2)') ISTRT 
         END IF
         IF (PREVID(9:14).EQ.ENDTIME(1:6)) THEN
             READ(ENDTIME,'(6X,I2)') IEND 
         END IF
      ELSE IF (ITYPE.LT.7) THEN
C          .. SYNOPTIC, HOURLY, AND 15 MINUTE DATA -- HOUR RANGE IS 
C             OF THE FORM 1,2,3,ETC.     
         IF (PREVID(9:16).EQ.STRTTIME(1:8)) THEN
            READ(STRTTIME,'(8X,I2)') ISTRT 
         END IF
         IF (PREVID(9:16).EQ.ENDTIME(1:8)) THEN
            READ(ENDTIME,'(8X,I2)') IEND 
         END IF
      END IF
      RETURN
      END
**************************************************************************

      SUBROUTINE MAXITEM(ITYPE,MXELEM,STRTID,ENDID,RTNCODE)
C
C       ** OBJECTIVE:  ROUTINE TO DETERMINE THE NUMBER OF DATA VALUES WHICH 
C                      WILL OCCUR BETWEEN STRTID AND ENDID.  IF THE NUMBER 
C                      IS > MXELEM - 2 THEN WARN THE USER.  THE TIME RANGE
C                      IS NOT ALLOWED TO CROSS FRAME BOUNDARIES FOR THE
C                      DATA TYPE.  (THIS ROITINE IS USED FOR MAPS ONLY)
C
      CHARACTER*18 STRTID,ENDID
      CHARACTER*6 MSGTXT
      CHARACTER*1 RTNCODE
      INTEGER BEGYR,BEGMON,BEGDAY,BEGHR,ENDYR,ENDMON,ENDDAY,ENDHR
      INTEGER*4 NUMVAL
C
      READ (STRTID,'(8X,I4,3I2)') BEGYR,BEGMON,BEGDAY,BEGHR
      READ (ENDID,'(8X,I4,3I2)') ENDYR,ENDMON,ENDDAY,ENDHR
C
C       ** ALL DATA TYPES -- BEGIN YEAR MUST EQUAL END YEAR
      IF (BEGYR .NE. ENDYR) GO TO 900
      IF (ITYPE .LE. 2) THEN
C
C          .. MONTHLY,10 DAY DATA - CALCULATE NUMBER OF VALUES FROM MONTH RANGE
         NUMVAL = ENDMON-BEGMON+1
      ELSE
C
C          .. DAILY, SYNOPTIC, HOURLY, 15 MINUTE DATA -- NO MONTH RANGE 
C             ALLOWED.  CHECK FOR VALID NUMBER OF DAYS FOR MONTH AND YEAR
         IF (BEGMON .NE. ENDMON) GO TO 900       
         CALL IDAYMON(ENDYR,ENDMON,MXDAY)
         IF (ENDDAY.GT.MXDAY) GO TO 930
         IF (ITYPE .EQ. 3) THEN
C   
C             .. DAILY DATA -- CALCULATE NUMBER OF VALUES FROM DAY RANGE
            NUMVAL = ENDDAY-BEGDAY+1
         ELSE    
C
C             .. SYNOPTIC, HOURLY, 15 MINUTE DATA -- NO DAY RANGE 
C                ALLOWED.  CALCULATE NUMBER OF VALUES FROM HOUR RANGE
            IF (BEGDAY .NE. ENDDAY) GO TO 900       
            NUMVAL = ENDHR - BEGHR + 1
         ENDIF   
      ENDIF      
      IF (NUMVAL.GT.MXELEM-2) THEN
         GO TO 910
      ENDIF
C
      RTNCODE = '0'
      RETURN
C
C       ** ERROR PROCESSING
C
  900 CONTINUE
C       .. DATE RANGE MUST NOT CROSS FRAME BOUNDARY  
      CALL WRTMSG(3,400,12,1,1,' ',0)
      GO TO 990
  910 CONTINUE
C       .. NUMBER VALUES IN SPECIFIED DATE RANGE EXCEEDS MXELEM-2      
      WRITE(MSGTXT,'(I3)') MXELEM - 2
      CALL WRTMSG(3,377,12,1,1,MSGTXT,3)
      GO TO 990
  930 CONTINUE
C       .. INCORRECT NUMBER OF DAYS FOR THE CURRENT YEAR AND MONTH
      CALL WRTMSG(3,405,12,1,1,' ',0)
      GO TO 990
C      
  990 CONTINUE
      RTNCODE = '1'
      RETURN
      END
***********************************************************************

      SUBROUTINE STRVALS(DATASOURCE,ITYPE,IGRAPH,RECID,STRTTIME
     +           ,ENDTIME,JSTRT,JEND,JCOL,RECNUM,IDKEY,NBRELEM,NUMLOOP
     +           ,ROWHDR,GRAFELEM,LATLIST,LONLIST,VALUE,FLAGS
     +           ,HLDARRAY,MXDATCOL,MAXVAR,LVLNUM,ISTN,NUMSTN,ELEMFND)
C
C   ROUTINE TO WRITE INFORMATION FROM THE CURRENT INPUT DATA RECORD IN 
C   GRAFINIT INTO THE APPROPRIATE COLUMN(S) OF HLDARRAY.  IT ALSO CHECKS 
C   FOR BEGINNING AND ENDING DATES WITHIN A RECORD (DAYS 10-20 IN DAILY
C   DATA FOR EXAMPLE)
C
      CHARACTER*21 IDKEY
      CHARACTER*18 RECID
      CHARACTER*12 ROWHDR(*)
      CHARACTER*10 STRTTIME,ENDTIME 
      CHARACTER*1 DATASOURCE,FLAGS(6)
      INTEGER*2 RECNUM, GRAFELEM(*)
      REAL*4 HLDARRAY(MXDATCOL,*),LATLIST(*)
     +      ,LONLIST(*)
      REAL*4 VALUE(MAXVAR)
      LOGICAL DATAOK,ELEMFND
$INCLUDE: 'VAL1.INC'
C
C   THE FIRST SECTION BELOW USES DATA FROM THE KEY-ENTRY/QC FILE WHILE
C   THE SECOND SECTION USES DATA IN DATAEASE FORMAT.
C
      ELEMFND = .FALSE.
      IF (DATASOURCE.EQ.'D') THEN
         READ (20,REC=RECNUM) IDKEY,((VALARRAY(I,J),I=1,NUMELEM)
     +         ,J=1,NUMLOOP)
         DATAOK = .FALSE.
         DO 400 J1 = 1, NUMELEM
            JELEM = TBLELEM(J1)
            JCOL = 0
            DO 340 J = 1,NBRELEM
               IF (JELEM.EQ.GRAFELEM(J)) THEN
                  JCOL = J
                  GO TO 345
               END IF
340         CONTINUE    
345         CONTINUE
            IF (JCOL.GT.0) THEN
               ELEMFND = .TRUE.
               CALL SETLOOP(ITYPE,RECID,STRTTIME,ENDTIME,NUMLOOP
     +                      ,ISTRT,IEND)
C
C        FIRST WRITE OUT INFO FOR MAPS - USE DIFFERENT STORAGE SCHEME 
C        DEPENDING UPON IF USER REQUESTED ONE ELEMENT AND A RANGE OF TIMES
C        OR ONE TIME AND MULTIPLE ELEMENTS.
C
               IF (IGRAPH.EQ.2) THEN
                  ROWHDR(NUMSTN) = RECID(1:8)
                  HLDARRAY(1,NUMSTN) = LATLIST(ISTN) 
                  HLDARRAY(2,NUMSTN) = LONLIST(ISTN) 
                  IF (NBRELEM.GT.1) THEN
C                      .. MAP -- MULTIPLE ELEMENTS, ONE TIME   
                     JCOL = JCOL + 2
                     IF (VALARRAY(J1,JSTRT).EQ.'      ') THEN
                        HLDARRAY(JCOL,NUMSTN) = -99999.
                     ELSE
                        READ(VALARRAY(J1,JSTRT),'(F5.0,1X)') RVAL
                        HLDARRAY(JCOL,NUMSTN) = RVAL*TBLCONV(J1)
                        DATAOK = .TRUE.
                     END IF
                  ELSE
C                      .. MAP -- MULTIPLE TIMES, ONE ELEMENT                  
                     DO 350 J2 = JSTRT,JEND
                        J3 = J2 - JSTRT + 3
                        IF (VALARRAY(J1,J2).EQ.'      ') THEN
                           HLDARRAY(J3,NUMSTN) = -99999.
                        ELSE
                           READ(VALARRAY(J1,J2),'(F5.0,1X)') RVAL
                           HLDARRAY(J3,NUMSTN)=RVAL*TBLCONV(J1)
                           DATAOK = .TRUE.
                        END IF
350                  CONTINUE
                  END IF
C
C         WRITE OUT THE INFORMATION FOR NON-MAP GRAPHICS
C
               ELSE                    
                  DO 380 I1 = ISTRT,IEND
                     IF (VALARRAY(J1,I1).EQ.'      ') THEN
                        HLDARRAY(JCOL,I1) = -99999.
                     ELSE
                        READ(VALARRAY(J1,I1),'(F5.0,1X)') RVAL
                        HLDARRAY(JCOL,I1) = RVAL*TBLCONV(J1)
                     END IF
380               CONTINUE
               END IF
            END IF
400      CONTINUE
C
C      IF NO DATA FOUND FOR THE ELEMENTS WANTED AND THIS STATION, SET
C      STN COUNTER BACK TO RE-USE THIS ENTRY IN HLDARRAY.
C
         IF (.NOT.DATAOK) THEN
            NUMSTN = NUMSTN - 1
         END IF
      ELSE 
C
C          **  USE DATA IN DATAEASE FORMAT
C
         ELEMFND = .TRUE.
         IF (IGRAPH.EQ.2) THEN
C         
C             ** WRITE OUT THE INFORMATION FOR MAP GRAPHICS 
C
            ROWHDR(NUMSTN) = RECID(1:8)
            HLDARRAY(1,NUMSTN) = LATLIST(ISTN) 
            HLDARRAY(2,NUMSTN) = LONLIST(ISTN) 
            IF (NBRELEM.GT.1) THEN
C            
C                .. ONE TIME AND MULTIPLE ELEMENTS
               HLDARRAY(JCOL+2,NUMSTN) = VALUE(JSTRT)
            ELSE
C            
C                .. ONE ELEMENT AND A RANGE OF TIMES            
               DO 480 I1 = JSTRT,JEND
                  HLDARRAY(I1-JSTRT+3,NUMSTN) = VALUE(I1)
480            CONTINUE
            END IF
         ELSE                    
C         
C             ** WRITE OUT THE INFORMATION FOR NON-MAP GRAPHICS 
C
            IF (ITYPE.EQ.7) THEN
C            
C                .. UPPER AIR DATA IS TREATED DIFFERENTLY THAN THE OTHERS 
C                   BECAUSE IT CONTAINS MULTIPLE ELEMENTS PER RECORD
               DO 490 JCOL = 1,6
                  IF (FLAGS(JCOL).EQ.'M') THEN
                     HLDARRAY(JCOL,LVLNUM) = -99999.
                  ELSE
                     HLDARRAY(JCOL,LVLNUM) = VALUE(JCOL)
                  END IF
490            CONTINUE
            ELSE
C            
C                 .. ALL DATA TYPES EXCEPT FOR UPPER AIR
                CALL SETLOOP(ITYPE,RECID,STRTTIME,ENDTIME,NUMLOOP
     +                   ,ISTRT,IEND)
               DO 550 I1 = ISTRT,IEND
                  HLDARRAY(JCOL,I1) = VALUE(I1)
550            CONTINUE
            END IF
         END IF
      END IF

      RETURN
      END
************************************************************************
      SUBROUTINE SETRANGE(ITYPE,ICNTRL,FIELD,HOURLBL,
     +                    STRTID,ENDID,NMSG,CMSG,RTNFLAG)
C
C   ROUTINE TO SET THE START AND END ID'S USING THE VALUES FROM FIELD
C   THAT ARE APPROPRIATE FOR THE OBS-TYPE AND GRAPH TYPE (ICNTRL) 
C   SPECIFIED.  BEGINNING AND ENDING DATES ARE CHECKED FOR CONSISTENCY.
C
C   
C
C   ICNTRL = 1 FOR MAPS WITH MULTITPLE ELEMENTS SELECTED
C          = 0 FOR ALL OTHER GRAPH TYPES

      CHARACTER*18 STRTID, ENDID
      CHARACTER*8 FIELD(10)
      CHARACTER*2 HOURLBL(*),RTNFLAG
      CHARACTER*(*) CMSG
C      
      CHARACTER*2 BEGHRFLD,ENDHRFLD
C
      STRTID  = ' '
      ENDID   = ' '
      CMSG    = ' '
      RTNFLAG = ' '
C
C       ** IF SYNOPTIC OR HOURLY DATA, CONVERT HOUR LABELS TO A LOOP 
C          COUNTER FORM: 1,2,3,ETC -- UPPER AIR HOUR LABELS ARE USED ONLY AS
C          LABELS AND NEVER ARE USED AS LOOP COUNTER.  ALL OTHER DATA TYPES 
C          ARE ALREADY IN THE CORRECT FORMAT
C
      IF (ITYPE.GT.3) THEN
         BEGHRFLD = FIELD(6)(1:2)
         IF (ICNTRL.EQ.0) THEN
            ENDHRFLD = FIELD(10)(1:2)
         ENDIF   
         IF (ITYPE.EQ.4) THEN
C             .. SYNOPTIC DATA
            CMSG = BEGHRFLD
            CALL GTHRINDX(HOURLBL,8,BEGHRFLD,RTNFLAG)
            IF (ICNTRL.EQ.0 .AND. RTNFLAG.NE.'ER') THEN
               CMSG = ENDHRFLD
               CALL GTHRINDX(HOURLBL,8,ENDHRFLD,RTNFLAG)
            ENDIF   
         ELSE IF (ITYPE.EQ.5) THEN
C             .. HOURLY DATA            
            CMSG = BEGHRFLD
            CALL GTHRINDX(HOURLBL,24,BEGHRFLD,RTNFLAG)
            IF (ICNTRL.EQ.0.AND. RTNFLAG.NE.'ER') THEN
               CMSG = ENDHRFLD
               CALL GTHRINDX(HOURLBL,24,ENDHRFLD,RTNFLAG)
            ENDIF   
         ENDIF                         
         IF (RTNFLAG.EQ.'ER') THEN
            NMSG = 401
            RETURN
         ELSE
            CMSG = ' '   
         ENDIF   
      ENDIF                         
C
C   FOR MAPS WITH MULTIPLE ELEMENTS ONLY A SINGLE DATE CAN BE SELECTED
C   SO MOVE THE VALUES INTO THE ID FIELDS
C
      IF (ICNTRL.EQ.1) THEN
         IF (ITYPE.LE.2) THEN
C             .. MONTHLY AND 10 DAY DATA -- STNID, YEAR, MONTH         
            STRTID = FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)
            ENDID = FIELD(2)//FIELD(3)(1:4)//FIELD(4)(1:2)
         ELSE IF (ITYPE.EQ.3) THEN
C             .. DAILY DATA -- STNID, YEAR, MONTH, DAY         
            STRTID=FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)//FIELD(5)(1:2)
            ENDID=FIELD(2)//FIELD(3)(1:4)//FIELD(4)(1:2)//FIELD(5)(1:2)
         ELSE
C             .. SYNOPTIC, HOURLY, 15 MINUTE, UPPER AIR
C                STNID, YEAR, MONTH, DAY, HOUR
            STRTID = FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)//
     +               FIELD(5)(1:2)//BEGHRFLD
            ENDID = FIELD(2)//FIELD(3)(1:4)//FIELD(4)(1:2)//
     +              FIELD(5)(1:2)//BEGHRFLD
         END IF
C
C   OTHERWISE A RANGE OF DATES CAN BE SELECTED SO CHECK THEM FOR
C   CONSISTENCY AND THEN IF OK MOVE THEM INTO THE ID FIELDS
C
      ELSE
         IF (ITYPE.LE.2) THEN
            STRTID = FIELD(3)(1:4)//FIELD(4)(1:2)
            ENDID = FIELD(5)(1:4)//FIELD(6)(1:2)
         ELSE IF (ITYPE.EQ.3) THEN
            STRTID = FIELD(3)(1:4)//FIELD(4)(1:2)//FIELD(5)(1:2)
            ENDID = FIELD(6)(1:4)//FIELD(7)(1:2)//FIELD(8)(1:2)
         ELSE IF (ITYPE.GT.3) THEN
            STRTID = FIELD(3)(1:4)//FIELD(4)(1:2)//FIELD(5)(1:2)//
     +               BEGHRFLD
            ENDID = FIELD(7)(1:4)//FIELD(8)(1:2)//FIELD(9)(1:2)//
     +              ENDHRFLD
         END IF
         IF (STRTID.GT.ENDID) THEN
            RTNFLAG = 'ER'
            NMSG = 71
            RETURN
         END IF
C
C     DATES ARE OK, COMBINE STATION AND DATES INTO ID FIELD
C
         IF (ITYPE.LE.2) THEN
            STRTID = FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)
            ENDID = FIELD(2)//FIELD(5)(1:4)//FIELD(6)(1:2)
         ELSE IF (ITYPE.EQ.3) THEN
            STRTID = FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)//
     +               FIELD(5)(1:2)
            ENDID = FIELD(2)//FIELD(6)(1:4)//FIELD(7)(1:2)//
     +              FIELD(8)(1:2)
         ELSE
            STRTID = FIELD(1)//FIELD(3)(1:4)//FIELD(4)(1:2)//
     +               FIELD(5)(1:2)//BEGHRFLD
            ENDID = FIELD(2)//FIELD(7)(1:4)//FIELD(8)(1:2)//
     +              FIELD(9)(1:2)//ENDHRFLD
         END IF
      END IF
C
C   FILL ALL BLANK CHARACTERS WITH ZEROS.
C
      DO 50 I1 = 1,18
         IF (STRTID(I1:I1).EQ.' ') THEN
            STRTID(I1:I1) = '0'
         END IF
         IF (ENDID(I1:I1).EQ.' ') THEN
            ENDID(I1:I1) = '0'
         END IF
50    CONTINUE         
      RETURN
      END
      SUBROUTINE GTHRINDX(HOURLBL,NLBL,HOURFLD,RTNFLAG)
C      
C       ** OBJECTIVE:  GIVEN A FIELD CONTAINING AN HOUR LABEL SPECIFIED IN THE
C                      DATAQC.PRM FILE, RETURN THE VALUE OF THE INDEX TO THE
C                      LABEL POSITION IN THE LIST.  FOR EXAMPLE, IF THE DATA
C                      TYPE IS SYNOPTIC, THE LABEL LIST MIGHT BE 00,03,06,09,
C                      12,15,18,21.  IF THE INPUT LABEL IS '12', THE OUTPUT
C                      INDEX IS '05'.
C       ** INPUT:
C             HOURLBL....LIST OF HOUR LABELS AS SPECIFIED IN DATAQC.PRM
C             NLBL.......NUMBER OF HOUR LABELS IN THE LIST
C             HOURFLD....INPUT HOUR FIELD CONTAINING AN HOUR LABEL FROM 
C                        THE LIST
C       ** OUTPUT:
C             HOURFLD....OUTPUT HOUR FIELD CONTAINING THE INDEX TO THE 
C                        POSITION OF THE HOUR LABEL IN THE LIST
C             RTNFLAG....ERROR FLAG -- VALUE OF 'ER' INDICATES THE INPUT
C                        HOUR FIELD CONTAINS A VALUE NOT SPECIFIED IN THE LIST
C
      INTEGER*2   NLBL
      CHARACTER*2 HOURLBL(NLBL),HOURFLD,RTNFLAG
C            
      RTNFLAG = '  '
      DO 10 I=1,NLBL
         IF (HOURFLD.EQ.HOURLBL(I)) GO TO 11
   10 CONTINUE
         RTNFLAG = 'ER'
         RETURN
   11 CONTINUE  
      WRITE(HOURFLD,'(I2.2)') I
      RETURN
      END