$STORAGE:2
      SUBROUTINE SETGPAL(PALETTE,PALDEF)
C
C   ROUTINE TO SET THE CLICOM GRAPHICS PALETTE TO THE PALETTE NUMBER
C   PASSED.  IF PALETTE IS < 1 OR > 12 THEN THIS ROUTINE WRAPS. (0->12,
C   13->1)
C
C   INPUT:
C     PALETTE...PALETTE NUMBER WANTED
C     PALDEF....DEFINITION OF ALL 12 POSSIBLE PALETTES.
C   OUTPUT:
C     PALETTE...PALETTE NUMBER ALLOWED (ADJUSTED FOR VALUES < 0 OR > 12)
C
      INTEGER*2 PALETTE, PALDEF(16,12)
C
      IF (PALDEF(1,12).GE.0) THEN
         MAXPAL = 12
      ELSE
         MAXPAL = 11
      END IF
      
      IF (PALETTE.LT.1) THEN
         PALETTE = MAXPAL
      ELSE IF (PALETTE.GT.MAXPAL) THEN
         PALETTE = 1
      END IF
      CALL DEFPAL(PALDEF(1,PALETTE))
      RETURN
      END

      SUBROUTINE DEFPAL(PALCLR)
C
      INTEGER*2 PALCLR(16)
C      
      INTEGER*2 CLRVAL(16,3)
C **DEBUG      
C$INCLUDE:'SAVBUF.INC'
C      EQUIVALENCE (CLRVAL,I2BUF)
C
      INTEGER*2 IRGB(3)
C      
C       ** CONVERT CONVERT THE INTEGER COLOR VALUE TO RED/GREEN/BLUE
C          COMPONENTS (RANGE 0-3).  NORMALIZE COMPONENT VALUES TO A RANGE
C          OF 0-63.  RANGE MUST BE 0-63 FOR REPPAL TO WORK.  ARRAY PASSED
C          TO REPPAL HAS ALL REDS FOLLOWED BY ALL GREENS, ETC.
C
      DO 25 J=1,16
         CALL INT2RGB(PALCLR(J),IRGB)
         DO 20 I=1,3
            CLRVAL(J,I) = IRGB(I)*21
   20    CONTINUE      
   25 CONTINUE      
      CALL REPPAL(CLRVAL)
      RETURN
      END            
      
      SUBROUTINE DEFPPAL(PALCLR,BWREV,IER)
C
      INTEGER*2 PALCLR(16),IER
      LOGICAL BWREV
C      
      INTEGER*2 CLRVAL(3,16)
C DEBUG      
C$INCLUDE:'SAVBUF.INC'
C      EQUIVALENCE (CLRVAL,I2BUF)
C
      INTEGER*2 IRGB(3)
C      
C       ** CONVERT CONVERT THE INTEGER COLOR VALUE TO RED/GREEN/BLUE
C          COMPONENTS (RANGE 0-3).  NORMALIZE COMPONENT VALUES TO A RANGE
C          OF 0-255.  RANGE MUST BE 0-255 FOR REPPRN TO WORK.  ARRAY PASSED
C          TO REPPRN HAS RGB COMPONENTS FOR COLOR INDEX 0, FOLLOWED BY RGB
C          COMPONENTS FOR COLOR INDEX 1, ETC.
C
      DO 25 J=1,16
         IF (PALCLR(J).EQ.333 .AND. BWREV) THEN
            DO 20 I=1,3
               CLRVAL(I,J) = 0
   20       CONTINUE      
         ELSE IF (PALCLR(J).EQ.0 .AND. BWREV) THEN
            DO 21 I=1,3
               CLRVAL(I,J) = 255
   21       CONTINUE      
         ELSE
            CALL INT2RGB(PALCLR(J),IRGB)
            DO 22 I=1,3
               CLRVAL(I,J) = IRGB(I)*85
   22       CONTINUE      
         ENDIF 
   25 CONTINUE      
      CALL REPPRN(CLRVAL)
      CALL CKHALOER(0,'REPPRN',IER)
      RETURN
      END            

      SUBROUTINE DEFCLR(INDEX,ICLR3,CURDEV)
C
C       ** INPUT:
C            INDEX....COLOR INDEX (0-15)
C            ICLR3....RED GREEN BLUE VALUES (0-3) 
C            CURDEV...DEVICE TYPE -- USED TO DETERMINE THE VALUE TO WHICH 
C                     THE COLOR COMPONENTS WILL BE NORMALIZED -- ALLOWED
C                     VALUES:  SCR  VRI
C
      INTEGER*2   INDEX,ICLR3(3)
      CHARACTER*3 CURDEV
C      
      PARAMETER (NTYP=2)
      INTEGER*2 ICLRNRM(3),NRMVAL(NTYP)
      CHARACTER*3 DEVTYP(NTYP)
      DATA DEVTYP/'VRI','SCR'/
      DATA NRMVAL/255,63/
      
C     
      NRMFAC = NRMVAL(1)/3
      DO 10 I=1,NTYP
         IF (CURDEV.EQ.DEVTYP(I)) THEN 
            NRMFAC = NRMVAL(I)/3
         ENDIF
   10 CONTINUE         
C      
C       .. CONVERT RED GREEN BLUE VALUES FROM 0-3 TO 0-NRMVAL
      DO 20 I=1,3
         ICLRNRM(I) = ICLR3(I)*NRMFAC
   20 CONTINUE      
C **DEBUG            
C            WRITE(*,*)'BEF SETCPA IDX,IC=',INDEX,(ICLRNRM(I),I=1,3)
      CALL SETCPA(INDEX,ICLRNRM(1),ICLRNRM(2),ICLRNRM(3))
C      
      RETURN
      END
      